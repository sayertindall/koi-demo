<file_summary>
================================================
REPO: blockscience/koi-net
================================================
</file_summary>

Directory structure:
└── blockscience-koi-net/
    ├── README.md
    ├── koi-net-protocol-openapi.json
    ├── LICENSE
    ├── pyproject.toml
    ├── requirements.txt
    ├── examples/
    │   ├── basic_coordinator_node.py
    │   ├── basic_partial_node.py
    │   ├── full_node_template.py
    │   └── partial_node_template.py
    ├── src/
    │   └── koi_net/
    │       ├── __init__.py
    │       ├── config.py
    │       ├── core.py
    │       ├── identity.py
    │       ├── network/
    │       │   ├── __init__.py
    │       │   ├── graph.py
    │       │   ├── interface.py
    │       │   ├── request_handler.py
    │       │   └── response_handler.py
    │       ├── processor/
    │       │   ├── __init__.py
    │       │   ├── default_handlers.py
    │       │   ├── handler.py
    │       │   ├── interface.py
    │       │   └── knowledge_object.py
    │       └── protocol/
    │           ├── __init__.py
    │           ├── api_models.py
    │           ├── consts.py
    │           ├── edge.py
    │           ├── event.py
    │           ├── helpers.py
    │           └── node.py
    └── .github/
        └── workflows/
            └── publish-to-pypi.yml


Files Content:

================================================
FILE: README.md
================================================
# KOI-net

*This specification is the result of several iterations of KOI research, [read more here](https://github.com/BlockScience/koi).*

### Jump to Sections: 
- [Protocol](#protocol)
    - [Introduction](#introduction)
    - [Communication Methods](#communication-methods)
- [Quickstart](#quickstart)
    - [Setup](#setup)
    - [Creating a Node](#creating-a-node)
    - [Knowledge Processing](#knowledge-processing)
    - [Try It Out!](#try-it-out)
- [Advanced](#advanced)
    - [Knowledge Processing Pipeline](#knowledge-processing-pipeline)
    - [Knowledge Handlers](#knowledge-handlers)
        - [RID Handler](#rid-handler)
        - [Manifest Handler](#manifest-handler)
        - [Bundle Handler](#bundle-handler)
        - [Network Handler](#network-handler)
        - [Final Handler](#final-handler)
    - [Registering Handlers](#registering-handlers)
    - [Default Behavior](#default-behavior)
- [Implementation Reference](#implementation-reference)
    - [Node Interface](#node-interface)
    - [Node Identity](#node-identity)
    - [Network Interface](#network-interface)
        - [Network Graph](#network-graph)
        - [Request Handler](#request-handler)
        - [Response Handler](#response-handler)
    - [Processor Interface](#processor-interface)
- [Development](#development)
    - [Setup](#setup-1)
    - [Distribution](#distribution)

# Protocol
## Introduction

*This project builds upon and uses the [RID protocol](https://github.com/BlockScience/rid-lib) to identify and coordinate around knowledge objects.*

This protocol defines the standard communication patterns and coordination norms needed to establish and maintain Knowledge Organization Infrastructure (KOI) networks. KOI-nets are heterogenous compositions of KOI nodes, each of which is capable of autonomously inputting, processing, and outputting knowledge. The behavior of each node and configuration of each network can vary greatly, thus the protocol is designed to be a simple and flexible but interoperable foundation for future projects to build on. The protocol only governs communication between nodes, not how they operate internally. As a result we consider KOI-nets to be fractal-like, in that a network of nodes may act like a single node from an outside perspective.

Generated OpenAPI documentation is provided in this repository, and can be [viewed interactively with Swagger](https://generator.swagger.io/?url=https://raw.githubusercontent.com/BlockScience/koi-net/refs/heads/main/koi-net-protocol-openapi.json).

## Communication Methods

There are two classes of communication methods, event and state communication. 
- Event communication is one way, a node send an event to another node. 
- State communication is two way, a node asks another node for RIDs, manifests, or bundles and receives a response containing the requested resource (if available).

There are also two types of nodes, full and partial nodes. 
- Full nodes are web servers, implementing the endpoints defined in the KOi-net protocol. They are capable of receiving events via webhooks (another node calls their endpoint), and serving state queries. They can also call the endpoints of other full nodes to broadcast events or retrieve state. 
- Partial nodes are web clients and don't implement any API endpoints. They are capable of receiving events via polling (asking another node for events). They can also call the endpoints of full nodes to broadcast events or retrieve state.

There are five endpoints defined by the API spec. The first two are for event communication with full and partial nodes respectively. The remaining three are for state communication with full nodes. As a result, partial nodes are unable to directly transfer state and may only output events to other nodes.
- Broadcast events - `/events/broadcast`
- Poll events - `/events/poll`
- Fetch bundles - `/bundles/fetch`
- Fetch manifests - `/manifests/fetch`
- Fetch RIDs - `/rids/fetch`

All endpoints are called with via POST request with a JSON body, and will receive a response containing a JSON payload (with the exception of broadcast events, which won't return anything). The JSON schemas can be found in the attached OpenAPI specification or the Pydantic models in the "protocol" module.

The request and payload JSON objects are composed of the fundamental "knowledge types" from the RID / KOI-net system: RIDs, manifests, bundles, and events. RIDs, manifests, and bundles are defined by the RID protocol and imported from rid-lib, which you can [read about here](https://github.com/BlockScience/rid-lib). Events are now part of the KOI-net protocol, and are defined as an RID and an event type with an optional manifest and contents. 

```json
{
    "rid": "...",
    "event_type": "NEW | UPDATE | FORGET",
    "manifest": {
        "rid": "...",
        "timestamp": "...",
        "sha256_hash": "...",
    },
    "contents": {}
}
```

An event is a signalling construct that conveys information about RID objects between networked nodes. Events are composed of an RID, manifest, or bundle with an event type attached. Event types can be one of `"FORGET"`, `"UPDATE"`, or `"NEW"` forming the "FUN" acronym. 

As opposed to CRUD (create, read, update, delete), events are a series of messages, not operations. Each node has its own autonomy in deciding how to react based on the message it receives. For example, a processor node may receive a `"NEW"` event for an RID object its not interested in, and ignore it. Or it may decide that an `"UPDATE"` event should trigger fetching a bundle from another node. A node emits an event to indicate that its internal state has changed:
- `"NEW"` - indicates an previously unknown RID was cached
- `"UPDATE"` - indicates a previously known RID was cached
- `"FORGET"` - indicates a previously known RID was deleted

Nodes may broadcast events to other nodes to indicate their internal state changed. Conversely, nodes may also listen to events from other nodes and as a result decide to change their internal state, take some other action, or do nothing.


# Quickstart
## Setup

The bulk of the code in this repo is taken up by the Python reference implementation, which can be used in other projects to easily set up and configure your own KOI-net node.

This package can be installed with pip:
```shell
pip install koi-net
```

## Creating a Node

*Check out the `examples/` folder to follow along!*

All of the KOI-net functionality comes from the `NodeInterface` class which provides methods to interact with the protocol API, a local RID cache, a view of the network, and an internal processing pipeline. To create a new node, you will need to give it a name and a profile. The name will be used to generate its unique node RID, and the profile stores basic configuration data which will be shared with the other nodes that you communciate with.

Your first decision will be whether to setup a partial or full node:
- Partial nodes only need to indicate their type, and optionally the RID types of events they provide.
- Full nodes need to indicate their type, the base URL for their KOI-net API, and optionally the RID types of events and state they provide.

### Partial Node
```python
from koi_net import NodeInterface
from koi_net.protocol.node import NodeProfile, NodeProvides, NodeType

node = NodeInterface(
    name="mypartialnode",
    profile=NodeProfile(
        node_type=NodeType.PARTIAL,
        provides=NodeProvides(
            event=[]
        )
    )
)
```
### Full Node
```python
from koi_net import NodeInterface
from koi_net.protocol.node import NodeProfile, NodeProvides, NodeType

node = NodeInterface(
    name="myfullnode",
    profile=NodeProfile(
        base_url="http://127.0.0.1:8000",
        node_type=NodeType.FULL,
        provides=NodeProvides(
            event=[],
            state=[]
        )
    ),
    use_kobj_processor_thread=True
)
```

When creating a node, you optionally enable `use_kobj_processor_thread` which will run the knowledge processing pipeline on a separate thread. This thread will automatically dequeue and process knowledge objects as they are added to the `kobj_queue`, which happenes when you call `node.process.handle(...)`. This is required to prevent race conditions in asynchronous applications, like web servers, therefore it is recommended to enable this feature for all full nodes. 

## Knowledge Processing

Next we'll set up the knowledge processing flow for our node. This is where most of the node's logic and behavior will come into play. For partial nodes this will be an event loop, and for full nodes we will use webhooks. Make sure to call `node.start()` and `node.stop()` at the beginning and end of your node's life cycle.

### Partial Node
Make sure to set `source=KnowledgeSource.External` when calling `handle` on external knowledge, this indicates to the knowledge processing pipeline that the incoming knowledge was received from another node. Where the knowledge is sourced from will impact decisions in the node's knowledge handlers.
```python
import time
from koi_net.processor.knowledge_object import KnowledgeSource

if __name__ == "__main__":
    node.start()

    try:
        while True:
            for event in node.network.poll_neighbors():
                node.processor.handle(event=event, source=KnowledgeSource.External)
            node.processor.flush_kobj_queue()
            
            time.sleep(5)
            
    finally:
        node.stop()
```

### Full Node
Setting up a full node is slightly more complex as we'll need a webserver. For this example, we'll use FastAPI and uvicorn. First we need to setup the "lifespan" of the server, to start and stop the node before and after execution, as well as the FastAPI app which will be our web server.
```python
from contextlib import asynccontextmanager
from fastapi import FastAPI

@asynccontextmanager
async def lifespan(app: FastAPI):
    node.start()
    yield
    node.stop()


app = FastAPI(lifespan=lifespan, root_path="/koi-net")
```

Next we'll add our event handling webhook endpoint, which will allow other nodes to broadcast events to us. You'll notice that we have a similar loop to our partial node, but instead of polling periodicially, we handle events asynchronously as we receive them from other nodes.

```python
from koi_net.protocol.api_models import *
from koi_net.protocol.consts import *

@app.post(BROADCAST_EVENTS_PATH)
def broadcast_events(req: EventsPayload):
    for event in req.events:
        node.processor.handle(event=event, source=KnowledgeSource.External)
```

Next we can add the event polling endpoint, this allows partial nodes to receive events from us.

```python
@app.post(POLL_EVENTS_PATH)
def poll_events(req: PollEvents) -> EventsPayload:
    events = node.network.flush_poll_queue(req.rid)
    return EventsPayload(events=events)
```

Now for the state transfer "fetch" endpoints:
```python
@app.post(FETCH_RIDS_PATH)
def fetch_rids(req: FetchRids) -> RidsPayload:
    return node.network.response_handler.fetch_rids(req)

@app.post(FETCH_MANIFESTS_PATH)
def fetch_manifests(req: FetchManifests) -> ManifestsPayload:
    return node.network.response_handler.fetch_manifests(req)

@app.post(FETCH_BUNDLES_PATH)
def fetch_bundles(req: FetchBundles) -> BundlesPayload:
    return node.network.response_handler.fetch_bundles(req)
```

Finally we can run the server!

```python
import uvicorn

if __name__ == "__main__":
    # update this path to the Python module that defines "app"
    uvicorn.run("examples.full_node_template:app", port=8000)
```

*Note: If your node is not the first node in the network, you'll also want to set up a "first contact" in the `NodeInterface`. This is the URL of another full node that can be used to make your first connection and find out about other nodes in the network.*

## Try It Out!

In addition to the partial and full node templates, there's also example implementations that showcase a coordinator + partial node setup. You can run both of them locally after cloning this repository. First, install the koi-net library with the optional examples requirements from the root directory in the repo:
```shell
pip install .[examples]
```
Then you can start each node in a separate terminal:
```shell
python -m examples.basic_coordinator_node
```
```shell
python -m examples.basic_partial_node
```

# Advanced

## Knowledge Processing Pipeline
Beyond the `NodeInterface` setup and boiler plate for partial/full nodes, node behavior is mostly controlled through the use of knowledge handlers. Effectively creating your own handlers relies on a solid understanding of the knowledge processing pipeline, so we'll start with that. As a developer, you will interface with the pipeline through the `ProcessorInterface` accessed with `node.processor`. The pipeline handles knowledge objects, from the `KnowledgeObject` class, a container for all knowledge types in the RID / KOI-net ecosystem:
- RIDs
- Manifests
- Bundles
- Events

Here is the class definition for a knowledge object:
```python
type KnowledgeEventType = EventType | None

class KnowledgeSource(StrEnum):
    Internal = "INTERNAL"
    External = "EXTERNAL"

class KnowledgeObject(BaseModel):
    rid: RID
    manifest: Manifest | None = None
    contents: dict | None = None
    event_type: KnowledgeEventType = None
    source: KnowledgeSource
    normalized_event_type: KnowledgeEventType = None
    network_targets: set[KoiNetNode] = set()
```

In addition to the fields required to represent the knowledge types (`rid`, `manifest`, `contents`, `event_type`), knowledge objects also include a `source` field, indicating whether the knowledge originated from within the node (`KnowledgeSource.Internal`) or from another node (`KnowledgeSource.External`).

The final two fields are not inputs, but are set by handlers as the knowledge object moves through the processing pipeline. The normalized event type indicates the event type normalized to the perspective of the node's cache, and the network targets indicate where the resulting event should be broadcasted to.

Knowledge objects enter the processing pipeline through the `node.processor.handle(...)` method. Using kwargs you can pass any of the knowledge types listed above, a knowledge source, and an optional `event_type` (for non-event knowledge types). The handle function will simply normalize the provided knowledge type into a knowledge object, and put it in the `kobj_queue`, an internal, thread-safe queue of knowledge objects. If you have enabled `use_kobj_processor_thread` then the queue will be automatically processed on the processor thread, otherwise you will need to regularly call `flush_kobj_queue` to process queued knowledge objects (as in the partial node example). Both methods will process knowledge objects sequentially, in the order that they were queued in (FIFO). 


## Knowledge Handlers

Processing happens through five distinct phases, corresponding to the handler types: `RID`, `Manifest`, `Bundle`, `Network`, and `Final`. Each handler type can be understood by describing (1) what knowledge object fields are available to the handler, and (2) what action takes place after this phase, which the handler can influence. As knowledge objects pass through the pipeline, fields may be added or updated. 

Handlers are registered in a single handler array within the processor. There is no limit to the number of handlers in use, and multiple handlers can be assigned to the same handler type. At each phase of knowledge processing, we will chain together all of the handlers of the corresponding type and run them in their array order. The order handlers are registered in matters!

Each handler will be passed a knowledge object. They can choose to return one of three types: `None`, `KnowledgeObject`, or `STOP_CHAIN`. Returning `None` will pass the unmodified knowledge object (the same one the handler received) to the next handler in the chain. If a handler modified their knowledge object, they should return it to pass the new version to the next handler. Finally, a handler can return `STOP_CHAIN` to immediately stop processing the knowledge object. No further handlers will be called and it will not enter the next phase of processing.

Summary of processing pipeline:
```
RID -> Manifest -> Bundle -> [cache action] -> Network -> [network action] -> Final
           |
(skip if event type is "FORGET")
```

### RID Handler
The knowledge object passed to handlers of this type are guaranteed to have an RID and knowledge source field. This handler type acts as a filter, if none of the handlers return `STOP_CHAIN` the pipeline will progress to the next phase. The pipeline diverges slightly after this handler chain, based on the event type of the knowledge object.

If the event type is `"NEW"`, `"UPDATE"`, or `None` and the manifest is not already in the knowledge object, the node will attempt to retrieve it from (1) the local cache if the source is internal, or (2) from another node if the source is external. If it fails to retrieves the manifest, the pipeline will end. Next, the manifest handler chain will be called.

If the event type is `"FORGET"`, and the bundle (manifest + contents) is not already in the knowledge object, the node will attempt to retrieve it from the local cache, regardless of the source. In this case the knowledge object represents what we will delete from the cache, not new incoming knowledge. If it fails to retrieve the bundle, the pipeline will end. Next, the bundle handler chain will be called.

### Manifest Handler
The knowledge object passed to handlers of this type are guaranteed to have an RID, manifest, and knowledge source field. This handler type acts as a filter, if none of the handlers return `STOP_CHAIN` the pipeline will progress to the next phase.

If the bundle (manifest + contents) is not already in the knowledge object, the node will attempt to retrieve it from (1) the local cache if the source is internal, or (2) from another node if the source is external. If it fails to retrieve the bundle, the pipeline will end. Next, the bundle handler chain will be called.

### Bundle Handler
The knowledge object passed to handlers of this type are guaranteed to have an RID, manifest, bundle (manifest + contents), and knowledge source field. This handler type acts as a decider. In this phase, the knowledge object's normalized event type must be set to `"NEW"` or `"UPDATE"` to write it to cache, or `"FORGET"` to delete it from the cache. If the normalized event type remains unset (`None`), or a handler returns `STOP_CHAIN`, then the pipeline will end without taking any cache action.

The cache action will take place after the handler chain ends, so if multiple handlers set a normalized event type, the final handler will take precedence.

### Network Handler
The knowledge object passed to handlers of this type are guaranteed to have an RID, manifest, bundle (manifest + contents), normalized event type, and knowledge source field. This handler type acts as a decider. In this phase, handlers decide which nodes to broadcast this knowledge object to by appending KOI-net node RIDs to the knowledge object's `network_targets` field. If a handler returns `STOP_CHAIN`, the pipeline will end without taking any network action.

The network action will take place after the handler chain ends. The node will attempt to broadcast a "normalized event", created from the knowledge object's RID, bundle, and normalized event type, to all of the node's in the network targets array. 

### Final Handler
The knowledge object passed to handlers of this type are guaranteed to have an RID, manifest, bundle (manifest + contents), normalized event type, and knowledge source field.

This is the final handler chain that is called, it doesn't make any decisions or filter for succesive handler types. Handlers here can be useful if you want to take some action after the network broadcast has ended.

## Registering Handlers
Knowledge handlers are registered with a node's processor by decorating a handler function. There are two types of decorators, the first way converts the function into a handler object which can be manually added to a processor. This is how the default handlers are defined, and makes them more portable (could be imported from another package). The second automatically registers a handler with your node instance. This is not portable but more convenient. The input of the decorated function will be the processor instance, and a knowledge object.

```python
from .handler import KnowledgeHandler, HandlerType, STOP_CHAIN

@KnowledgeHandler.create(HandlerType.RID)
def example_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    ...

@node.processor.register_handler(HandlerType.RID)
def example_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    ...
```

While handler's only require specifying the handler type, you can also specify the RID types, knowledge source, or event types you want to handle. If a knowledge object doesn't match all of the specified parameters, it won't be called. By default, handlers will match all RID types, all event types, and both internal and external sourced knowledge.

```python
@KnowledgeHandler.create(
    handler_type=HandlerType.Bundle, 
    rid_types=[KoiNetEdge], 
    source=KnowledgeSource.External,
    event_types=[EventType.NEW, EventType.UPDATE])
def edge_negotiation_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    ...
```

The processor instance passed to your function should be used to take any necessary node actions (cache, network, etc.). It is also sometimes useful to add new knowledge objects to the queue while processing a different knowledge object. You can simply call `processor.handle(...)` in the same way as you would outside of a handler. It will put at the end of the queue and processed when it is dequeued like any other knowledge object.


## Default Behavior

The default configuration provides four default handlers which will take precedence over any handlers you add yourself. To override this behavior, you can set the `handlers` field in the `NodeInterface`:

```python
from koi_net import NodeInterface
from koi_net.protocol.node import NodeProfile, NodeProvides, NodeType
from koi_net.processor.default_handlers import (
    basic_rid_handler,
    basic_manifest_handler,
    edge_negotiation_handler,
    basic_network_output_filter
)

node = NodeInterface(
    name="mypartialnode",
    profile=NodeProfile(
        node_type=NodeType.PARTIAL,
        provides=NodeProvides(
            event=[]
        )
    ),
    handlers=[
        basic_rid_handler,
        basic_manifest_handler,
        edge_negotiation_handler,
        basic_network_output_filter

        # include all or none of the default handlers
    ]
)
```

Take a look at `src/koi_net/processor/default_handlers.py` to see some more in depth examples and better understand the default node behavior.

# Implementation Reference
This section provides high level explanations of the Python implementation. More detailed explanations of methods can be found in the docstrings within the codebase itself.

## Node Interface
The node class mostly acts as a container for other classes with more specialized behavior, with special functions that should be called to start up and shut down a node. We'll take a look at each of these components in turn, but here is the class stub:
```python
class NodeInterface:
    cache: Cache
    identity: NodeIdentity
    network: NetworkInterface
    processor: ProcessorInterface
    first_contact: str
    use_kobj_processor_thread: bool

    def __init__(
        self, 
        name: str,
        profile: NodeProfile,
        identity_file_path: str = "identity.json",
        event_queues_file_path: str = "event_queues.json",
        cache_directory_path: str = "rid_cache",
        use_kobj_processor_thread: bool = False,
        first_contact: str | None = None,
        handlers: list[KnowledgeHandler] | None = None,
        cache: Cache | None = None,
        network: NetworkInterface | None = None,
        processor: ProcessorInterface | None = None
    ): ...

    def start(self): ...
    def stop(self): ...
```
As you can see, only a name and profile are required. The other fields allow for additional customization if needed.

## Node Identity
The `NodeIdentity` class provides easy access to a node's own RID, profile, and bundle. It provides access to the following properties after initialization, accessed with `node.identity`.
```python
class NodeIdentity:
    rid: KoiNetNode # an RID type
    profile: NodeProfile
    bundle: Bundle
```
This it what is initialized from the required `name` and `profile` fields in the `NodeInterface` constructor. Node RIDs take the form of `orn:koi-net.node:<name>+<uuid>`, and are generated on first use to the identity JSON file along with a the node profile.

## Network Interface
The `NetworkInterface` class provides access to high level network actions, and contains several other network related classes. It is accessed with `node.network`.
```python
class NetworkInterface:
    graph: NetworkGraph
    request_handler: RequestHandler
    response_handler: ResponseHandler

    def __init__(
        self, 
        file_path: str,
        first_contact: str | None,
        cache: Cache, 
        identity: NodeIdentity
    ): ...

    def push_event_to(self, event: Event, node: KoiNetNode, flush=False): ...
    
    def flush_poll_queue(self, node: KoiNetNode) -> list[Event]: ...
    def flush_webhook_queue(self, node: RID): ...

    def fetch_remote_bundle(self, rid: RID): ...
    def fetch_remote_manifest(self, rid: RID): ...

    def get_state_providers(self, rid_type: RIDType): ...
    def poll_neighbors(self) -> list[Event]: ...
```

Most of the provided functions are abstractions for KOI-net protocol actions. It also contains three lower level classes: `NetworkGraph`, `RequestHandler`, and `ResponseHandler`.

### Network Graph
The `NetworkGraph` class provides access to a graph view of the node's KOI network: all of the KOI-net node and edge objects it knows about (stored in local cache). This view allows us to query nodes that we have edges with to make networking decisions.
```python
class NetworkGraph:
    dg: nx.DiGraph

    def __init__(
        self,
        cache: Cache,
        identity: NodeIdentity
    ): ...

    def generate(self): ...

    def get_edges(
        self, 
        direction: Literal["in", "out"] | None = None
    ) -> list[KoiNetEdge]: ...

    def get_neighbors(
        self,
        direction: Literal["in", "out"] | None = None,
        status: EdgeStatus | None = None,
        allowed_type: RIDType | None = None
    ) -> list[KoiNetNode]: ...
    
    def get_node_profile(self, rid: KoiNetNode) -> NodeProfile | None: ...
    def get_edge_profile(
        self,
        rid: KoiNetEdge | None = None,
        source: KoiNetNode | None = None,
        target: KoiNetNode | None = None
    ) -> EdgeProfile | None: ...
```

### Request Handler
Handles raw API requests to other nodes through the KOI-net protocol. Accepts a node RID or direct URL as the target. Each method requires either a valid request model, or `kwargs` which will be converted to the correct model in `koi_net.protocol.api_models`.
```python
class RequestHandler:
    def __init__(self, cache: Cache, graph: NetworkGraph): ...

    def broadcast_events(
        self, 
        node: RID = None, 
        url: str = None, 
        req: EventsPayload | None = None,
        **kwargs
    ) -> None: ...

    def poll_events(
        self, 
        node: RID = None, 
        url: str = None, 
        req: PollEvents | None = None,
        **kwargs
    ) -> EventsPayload: ...

    def fetch_rids(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchRids | None = None,
        **kwargs
    ) -> RidsPayload: ...

    def fetch_manifests(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchManifests | None = None,
        **kwargs
    ) -> ManifestsPayload: ...

    def fetch_bundles(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchBundles | None = None,
        **kwargs
    ) -> BundlesPayload: ...
```

### Response Handler
Handles raw API responses to requests from other nodes through the KOI-net protocol.
```python
class ResponseHandler:
    def __init__(self, cache: Cache): ...

    def fetch_rids(self, req: FetchRids) -> RidsPayload:
    def fetch_manifests(self, req: FetchManifests) -> ManifestsPayload:
    def fetch_bundles(self, req: FetchBundles) -> BundlesPayload:
```
Only fetch methods are provided right now, event polling and broadcasting can be handled like this:
```python
def broadcast_events(req: EventsPayload) -> None:
    for event in req.events:
        node.processor.handle(event=event, source=KnowledgeSource.External)
    node.processor.flush_kobj_queue()

def poll_events(req: PollEvents) -> EventsPayload:
    events = node.network.flush_poll_queue(req.rid)
    return EventsPayload(events=events)
```

## Processor Interface
The `ProcessorInterface` class provides access to a node's internal knowledge processing pipeline.
```python
class ProcessorInterface:
    worker_thread: threading.Thread | None = None

    def __init__(
        self, 
        cache: Cache, 
        network: NetworkInterface,
        identity: NodeIdentity,
        use_kobj_processor_thread: bool,
        default_handlers: list[KnowledgeHandler] = []
    ): ...

    def add_handler(self, handler: KnowledgeHandler): ...
    
    def register_handler(
        self,
        handler_type: HandlerType,
        rid_types: list[RIDType] | None = None
    ): ...

    def process_kobj(self, kobj: KnowledgeObject) -> None:
    def flush_kobj_queue(self): ...

    def handle(
        self,
        rid: RID | None = None,
        manifest: Manifest | None = None,
        bundle: Bundle | None = None,
        event: Event | None = None,
        kobj: KnowledgeObject | None = None,
        event_type: KnowledgeEventType = None,
        source: KnowledgeSource = KnowledgeSource.Internal
    ): ...
```

The `register_handler` method is a decorator which can wrap a function to create a new `KnowledgeHandler` and add it to the processing pipeline in a single step. The `add_handler` method adds an existing `KnowledgeHandler` to the processining pipeline.

The most commonly used functions in this class are `handle` and `flush_kobj_queue`. The `handle` method can be called on RIDs, manifests, bundles, and events to convert them to normalized to `KnowledgeObject` instances which are then added to the processing queue. If you have enabled `use_kobj_processor_thread` then the queue will be automatically processed, otherwise you will need to regularly call `flush_kobj_queue` to process queued knolwedge objects. When calling the `handle` method, knowledge objects are marked as internally source by default. If you are handling RIDs, manifests, bundles, or events sourced from other nodes, `source` should be set to `KnowledgeSource.External`.

Here is an example of how an event polling loop would be implemented using the knowledge processing pipeline:
```python
for event in node.network.poll_neighbors():
    node.processor.handle(event=event, source=KnowledgeSource.External)
node.processor.flush_kobj_queue()
```

# Development
## Setup
Clone this repository:
```console
git clone https://github.com/BlockScience/koi-net
```
Set up and activate virtual environment:
```shell
python -m venv venv
```
Windows:
```shell
.\venv\Scripts\activate
```
Linux:
```shell
source venv/bin/activate
```
Install koi-net with dev dependencies:
```shell
pip install -e .[dev]
```
## Distribution
*Be careful! All files not in `.gitignore` will be included in the distribution, even if they aren't tracked by git! Double check the `.tar.gz` after building to make sure you didn't accidently include other files.*

Build package:
```shell
python -m build
```
Push new package build to PyPI:
```shell
python -m twine upload --skip-existing dist/*
```


================================================
FILE: koi-net-protocol-openapi.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "KOI-net Protocol API",
    "version": "1.0.0"
  },
  "paths": {
    "/events/broadcast": {
      "post": {
        "summary": "Broadcast Events",
        "operationId": "broadcast_events_events_broadcast_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventsPayload-Input"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/events/poll": {
      "post": {
        "summary": "Poll Events",
        "operationId": "poll_events_events_poll_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PollEvents"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EventsPayload-Output"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rids/fetch": {
      "post": {
        "summary": "Fetch Rids",
        "operationId": "fetch_rids_rids_fetch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FetchRids"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RidsPayload"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/manifests/fetch": {
      "post": {
        "summary": "Fetch Manifests",
        "operationId": "fetch_manifests_manifests_fetch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FetchManifests"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ManifestsPayload"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/bundles/fetch": {
      "post": {
        "summary": "Fetch Bundles",
        "operationId": "fetch_bundles_bundles_fetch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FetchBundles"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BundlesPayload"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Bundle": {
        "properties": {
          "manifest": {
            "$ref": "#/components/schemas/Manifest"
          },
          "contents": {
            "type": "object",
            "title": "Contents"
          }
        },
        "type": "object",
        "required": [
          "manifest",
          "contents"
        ],
        "title": "Bundle",
        "description": "A Knowledge Bundle composed of a manifest and optional contents associated with an RIDed object.\n\nA container object for the cached data associated with an RID. It is \nreturned by the read function of Cache."
      },
      "BundlesPayload": {
        "properties": {
          "bundles": {
            "items": {
              "$ref": "#/components/schemas/Bundle"
            },
            "type": "array",
            "title": "Bundles"
          },
          "not_found": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Not Found",
            "default": []
          },
          "deferred": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Deferred",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "bundles"
        ],
        "title": "BundlesPayload"
      },
      "Event": {
        "properties": {
          "rid": {
            "type": "string",
            "format": "rid",
            "title": "Rid"
          },
          "event_type": {
            "$ref": "#/components/schemas/EventType"
          },
          "manifest": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Manifest"
              },
              {
                "type": "null"
              }
            ]
          },
          "contents": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Contents"
          }
        },
        "type": "object",
        "required": [
          "rid",
          "event_type"
        ],
        "title": "Event"
      },
      "EventType": {
        "type": "string",
        "enum": [
          "NEW",
          "UPDATE",
          "FORGET"
        ],
        "title": "EventType"
      },
      "EventsPayload-Input": {
        "properties": {
          "events": {
            "items": {
              "$ref": "#/components/schemas/Event"
            },
            "type": "array",
            "title": "Events"
          }
        },
        "type": "object",
        "required": [
          "events"
        ],
        "title": "EventsPayload"
      },
      "EventsPayload-Output": {
        "properties": {
          "events": {
            "items": {
              "$ref": "#/components/schemas/Event"
            },
            "type": "array",
            "title": "Events"
          }
        },
        "type": "object",
        "required": [
          "events"
        ],
        "title": "EventsPayload"
      },
      "FetchBundles": {
        "properties": {
          "rids": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Rids"
          }
        },
        "type": "object",
        "required": [
          "rids"
        ],
        "title": "FetchBundles"
      },
      "FetchManifests": {
        "properties": {
          "rid_types": {
            "items": {
              "type": "string",
              "format": "rid-type"
            },
            "type": "array",
            "title": "Rid Types",
            "default": []
          },
          "rids": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Rids",
            "default": []
          }
        },
        "type": "object",
        "title": "FetchManifests"
      },
      "FetchRids": {
        "properties": {
          "rid_types": {
            "items": {
              "type": "string",
              "format": "rid-type"
            },
            "type": "array",
            "title": "Rid Types",
            "default": []
          }
        },
        "type": "object",
        "title": "FetchRids"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "Manifest": {
        "properties": {
          "rid": {
            "type": "string",
            "format": "rid",
            "title": "Rid"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp"
          },
          "sha256_hash": {
            "type": "string",
            "title": "Sha256 Hash"
          }
        },
        "type": "object",
        "required": [
          "rid",
          "timestamp",
          "sha256_hash"
        ],
        "title": "Manifest"
      },
      "ManifestsPayload": {
        "properties": {
          "manifests": {
            "items": {
              "$ref": "#/components/schemas/Manifest"
            },
            "type": "array",
            "title": "Manifests"
          },
          "not_found": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Not Found",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "manifests"
        ],
        "title": "ManifestsPayload"
      },
      "PollEvents": {
        "properties": {
          "rid": {
            "type": "string",
            "format": "rid",
            "title": "Rid"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "rid"
        ],
        "title": "PollEvents"
      },
      "RidsPayload": {
        "properties": {
          "rids": {
            "items": {
              "type": "string",
              "format": "rid"
            },
            "type": "array",
            "title": "Rids"
          }
        },
        "type": "object",
        "required": [
          "rids"
        ],
        "title": "RidsPayload"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      }
    }
  }
}


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 BlockScience

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "koi-net"
version = "1.0.0-beta.13"
description = "Implementation of KOI-net protocol in Python"
authors = [
    {name = "Luke Miller", email = "luke@block.science"}
]
readme = "README.md"
requires-python = ">=3.10"
license = {file = "LICENSE"}
dependencies = [
    "rid-lib>=3.2.1",
    "networkx>=3.4.2",
    "httpx>=0.28.1",
    "pydantic>=2.10.6"
]

[project.optional-dependencies]
dev = ["twine>=6.0", "build"]
examples = [
    "rich",
    "fastapi",
    "uvicorn"
]

[project.urls]
Homepage = "https://github.com/BlockScience/koi-net/"


================================================
FILE: requirements.txt
================================================
networkx>=3.4.2
rid-lib>=3.2.1
httpx>=0.28.1
pydantic>=2.10.6

# requirements for examples/
rich
fastapi
uvicorn


================================================
FILE: examples/basic_coordinator_node.py
================================================
import json
import logging
import uvicorn
from contextlib import asynccontextmanager
from rich.logging import RichHandler
from fastapi import FastAPI
from rid_lib.types import KoiNetNode, KoiNetEdge
from koi_net import NodeInterface
from koi_net.processor.handler import HandlerType
from koi_net.processor.knowledge_object import KnowledgeObject, KnowledgeSource
from koi_net.protocol.edge import EdgeType
from koi_net.protocol.event import Event, EventType
from koi_net.protocol.helpers import generate_edge_bundle
from koi_net.protocol.node import NodeProfile, NodeType, NodeProvides
from koi_net.processor import ProcessorInterface
from koi_net.protocol.api_models import (
    PollEvents,
    FetchRids,
    FetchManifests,
    FetchBundles,
    EventsPayload,
    RidsPayload,
    ManifestsPayload,
    BundlesPayload
)
from koi_net.protocol.consts import (
    BROADCAST_EVENTS_PATH,
    POLL_EVENTS_PATH,
    FETCH_RIDS_PATH,
    FETCH_MANIFESTS_PATH,
    FETCH_BUNDLES_PATH
)


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler()]
)

logging.getLogger("koi_net").setLevel(logging.DEBUG)

port = 8000

node = NodeInterface(
    name="coordinator",
    profile=NodeProfile(
        base_url=f"http://127.0.0.1:{port}/koi-net",
        node_type=NodeType.FULL,
        provides=NodeProvides(
            event=[KoiNetNode, KoiNetEdge],
            state=[KoiNetNode, KoiNetEdge]
        )
    ),
    use_kobj_processor_thread=True,
    cache_directory_path="coordinator_node_rid_cache",
    event_queues_file_path="coordinator_node_event_queus.json",
    identity_file_path="coordinator_node_identity.json",
)


logger = logging.getLogger(__name__)


@node.processor.register_handler(HandlerType.Network, rid_types=[KoiNetNode])
def handshake_handler(proc: ProcessorInterface, kobj: KnowledgeObject):    
    logger.info("Handling node handshake")

    # only respond if node declares itself as NEW
    if kobj.event_type != EventType.NEW:
        return
        
    logger.info("Sharing this node's bundle with peer")
    proc.network.push_event_to(
        event=Event.from_bundle(EventType.NEW, proc.identity.bundle),
        node=kobj.rid,
        flush=True
    )
    
    logger.info("Proposing new edge")    
    # defer handling of proposed edge
    proc.handle(bundle=generate_edge_bundle(
        source=kobj.rid,
        target=proc.identity.rid,
        edge_type=EdgeType.WEBHOOK,
        rid_types=[KoiNetNode, KoiNetEdge]
    ))



@asynccontextmanager
async def lifespan(app: FastAPI):
    node.start()
    yield
    node.stop()

app = FastAPI(
    lifespan=lifespan, 
    root_path="/koi-net",
    title="KOI-net Protocol API",
    version="1.0.0"
)

@app.post(BROADCAST_EVENTS_PATH)
def broadcast_events(req: EventsPayload):
    logger.info(f"Request to {BROADCAST_EVENTS_PATH}, received {len(req.events)} event(s)")
    for event in req.events:
        node.processor.handle(event=event, source=KnowledgeSource.External)
    
@app.post(POLL_EVENTS_PATH)
def poll_events(req: PollEvents) -> EventsPayload:
    logger.info(f"Request to {POLL_EVENTS_PATH}")
    events = node.network.flush_poll_queue(req.rid)
    return EventsPayload(events=events)

@app.post(FETCH_RIDS_PATH)
def fetch_rids(req: FetchRids) -> RidsPayload:
    return node.network.response_handler.fetch_rids(req)

@app.post(FETCH_MANIFESTS_PATH)
def fetch_manifests(req: FetchManifests) -> ManifestsPayload:
    return node.network.response_handler.fetch_manifests(req)

@app.post(FETCH_BUNDLES_PATH)
def fetch_bundles(req: FetchBundles) -> BundlesPayload:
    return node.network.response_handler.fetch_bundles(req)
    
if __name__ == "__main__":
    openapi_spec = app.openapi()

    with open("koi-net-protocol-openapi.json", "w") as f:
        json.dump(openapi_spec, f, indent=2)
    
    uvicorn.run("examples.basic_coordinator_node:app", port=port)


================================================
FILE: examples/basic_partial_node.py
================================================
import time
import logging
from rich.logging import RichHandler
from koi_net import NodeInterface
from koi_net.processor.handler import HandlerType
from koi_net.processor.knowledge_object import KnowledgeSource, KnowledgeObject
from koi_net.processor.interface import ProcessorInterface
from koi_net.protocol.event import EventType
from koi_net.protocol.edge import EdgeType
from koi_net.protocol.node import NodeProfile, NodeType
from koi_net.protocol.helpers import generate_edge_bundle
from rid_lib.types import KoiNetNode

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler()]
)

logging.getLogger("koi_net").setLevel(logging.DEBUG)
logger = logging.getLogger(__name__)


node = NodeInterface(
    name="partial",
    profile=NodeProfile(
        node_type=NodeType.PARTIAL
    ),
    cache_directory_path="partial_node_rid_cache",
    event_queues_file_path="parital_node_event_queus.json",
    identity_file_path="partial_node_identity.json",
    first_contact="http://127.0.0.1:8000/koi-net"
)

@node.processor.register_handler(HandlerType.Network, rid_types=[KoiNetNode])
def coordinator_contact(processor: ProcessorInterface, kobj: KnowledgeObject):
    # when I found out about a new node
    if kobj.normalized_event_type != EventType.NEW: 
        return
    
    node_profile = kobj.bundle.validate_contents(NodeProfile)
    
    # looking for event provider of nodes
    if KoiNetNode not in node_profile.provides.event:
        return
    
    logger.info("Identified a coordinator!")
    logger.info("Proposing new edge")
    
    # queued for processing
    processor.handle(bundle=generate_edge_bundle(
        source=kobj.rid,
        target=node.identity.rid,
        edge_type=EdgeType.POLL,
        rid_types=[KoiNetNode]
    ))
    
    logger.info("Catching up on network state")
    
    payload = processor.network.request_handler.fetch_rids(kobj.rid, rid_types=[KoiNetNode])
    for rid in payload.rids:
        if rid == processor.identity.rid:
            logger.info("Skipping myself")
            continue
        if processor.cache.exists(rid):
            logger.info(f"Skipping known RID '{rid}'")
            continue
        
        # marked as external since we are handling RIDs from another node
        # will fetch remotely instead of checking local cache
        processor.handle(rid=rid, source=KnowledgeSource.External)
    logger.info("Done")
    


node.start()

while True:
    for event in node.network.poll_neighbors():
        node.processor.handle(event=event, source=KnowledgeSource.External)
    node.processor.flush_kobj_queue()
    
    time.sleep(5)


================================================
FILE: examples/full_node_template.py
================================================
import logging
import uvicorn
from contextlib import asynccontextmanager
from rich.logging import RichHandler
from fastapi import FastAPI
from rid_lib.types import KoiNetNode, KoiNetEdge
from koi_net import NodeInterface
from koi_net.processor.knowledge_object import KnowledgeSource

from koi_net.protocol.node import NodeProfile, NodeType, NodeProvides
from koi_net.protocol.api_models import (
    PollEvents,
    FetchRids,
    FetchManifests,
    FetchBundles,
    EventsPayload,
    RidsPayload,
    ManifestsPayload,
    BundlesPayload
)
from koi_net.protocol.consts import (
    BROADCAST_EVENTS_PATH,
    POLL_EVENTS_PATH,
    FETCH_RIDS_PATH,
    FETCH_MANIFESTS_PATH,
    FETCH_BUNDLES_PATH
)


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler()]
)

logger = logging.getLogger(__name__)
logging.getLogger("koi_net").setLevel(logging.DEBUG)

port = 5000
coordinator_url = "http://127.0.0.1:8000/koi-net"

node = NodeInterface(
    name="coordinator",
    profile=NodeProfile(
        base_url=f"http://127.0.0.1:{port}/koi-net",
        node_type=NodeType.FULL,
        provides=NodeProvides(
            event=[KoiNetNode, KoiNetEdge],
            state=[KoiNetNode, KoiNetEdge]
        )
    ),
    use_kobj_processor_thread=True,
    first_contact=coordinator_url
)


@asynccontextmanager
async def lifespan(app: FastAPI):
    node.start()
    yield
    node.stop()


app = FastAPI(lifespan=lifespan, root_path="/koi-net")

@app.post(BROADCAST_EVENTS_PATH)
def broadcast_events(req: EventsPayload):
    logger.info(f"Request to {BROADCAST_EVENTS_PATH}, received {len(req.events)} event(s)")
    for event in req.events:
        node.processor.handle(event=event, source=KnowledgeSource.External)
    
@app.post(POLL_EVENTS_PATH)
def poll_events(req: PollEvents) -> EventsPayload:
    logger.info(f"Request to {POLL_EVENTS_PATH}")
    events = node.network.flush_poll_queue(req.rid)
    return EventsPayload(events=events)

@app.post(FETCH_RIDS_PATH)
def fetch_rids(req: FetchRids) -> RidsPayload:
    return node.network.response_handler.fetch_rids(req)

@app.post(FETCH_MANIFESTS_PATH)
def fetch_manifests(req: FetchManifests) -> ManifestsPayload:
    return node.network.response_handler.fetch_manifests(req)

@app.post(FETCH_BUNDLES_PATH)
def fetch_bundles(req: FetchBundles) -> BundlesPayload:
    return node.network.response_handler.fetch_bundles(req)
    
    
if __name__ == "__main__":
    # update this path to the Python module that defines "app"
    uvicorn.run("examples.full_node_template:app", port=port)


================================================
FILE: examples/partial_node_template.py
================================================
import time
import logging
from rich.logging import RichHandler
from koi_net import NodeInterface
from koi_net.processor.knowledge_object import KnowledgeSource
from koi_net.protocol.node import NodeProfile, NodeType


logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[RichHandler()]
)

logger = logging.getLogger(__name__)


coordinator_url = "http://127.0.0.1:8000/koi-net"

node = NodeInterface(
    name="partial",
    profile=NodeProfile(
        node_type=NodeType.PARTIAL,
    ),
    first_contact=coordinator_url
)

if __name__ == "__main__":
    node.start()

    try:
        while True:
            for event in node.network.poll_neighbors():
                node.processor.handle(event=event, source=KnowledgeSource.External)
            node.processor.flush_kobj_queue()
            
            time.sleep(5)
            
    finally:
        node.stop()


================================================
FILE: src/koi_net/__init__.py
================================================
from .core import NodeInterface


================================================
FILE: src/koi_net/config.py
================================================
import os
from typing import TypeVar
from ruamel.yaml import YAML
from koi_net.protocol.node import NodeProfile
from rid_lib.types import KoiNetNode
from pydantic import BaseModel, Field, PrivateAttr
from dotenv import load_dotenv


class ServerConfig(BaseModel):
    host: str | None = "127.0.0.1"
    port: int | None = 8000
    path: str | None = None
    
    @property
    def url(self):
        return f"http://{self.host}:{self.port}{self.path or ''}"

class KoiNetConfig(BaseModel):
    node_name: str
    node_rid: KoiNetNode | None = None
    node_profile: NodeProfile
    
    cache_directory_path: str | None = ".rid_cache"
    event_queues_path: str | None = "event_queues.json"

    first_contact: str | None = None

class EnvConfig(BaseModel):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        load_dotenv()
    
    def __getattribute__(self, name):
        value = super().__getattribute__(name)
        if name in type(self).model_fields:
            env_val = os.getenv(value)
            if env_val is None:
                raise ValueError(f"Required environment variable {value} not set")
            return env_val
        return value

class Config(BaseModel):
    server: ServerConfig | None = Field(default_factory=ServerConfig)
    koi_net: KoiNetConfig
    _file_path: str = PrivateAttr(default="config.yaml")
    _file_content: str | None = PrivateAttr(default=None)
    
    @classmethod
    def load_from_yaml(
        cls, 
        file_path: str | None = None, 
        generate_missing: bool = True
    ):
        yaml = YAML()
        
        try:
            with open(file_path, "r") as f:
                file_content = f.read()
            config_data = yaml.load(file_content)
            config = cls.model_validate(config_data)
            config._file_content = file_content
            
        except FileNotFoundError:
            config = cls()
            
        config._file_path = file_path
        
        if generate_missing:            
            config.koi_net.node_rid = (
                config.koi_net.node_rid or KoiNetNode.generate(config.koi_net.node_name)
            )   
            config.koi_net.node_profile.base_url = (
                config.koi_net.node_profile.base_url or config.server.url
            )
                
            config.save_to_yaml()
                    
        return config
    
    def save_to_yaml(self):
        yaml = YAML()
        
        with open(self._file_path, "w") as f:
            try:
                config_data = self.model_dump(mode="json")
                yaml.dump(config_data, f)
            except Exception as e:
                if self._file_content:
                    f.seek(0)
                    f.truncate()
                    f.write(self._file_content)
                raise e
                
ConfigType = TypeVar("ConfigType", bound=Config)



================================================
FILE: src/koi_net/core.py
================================================
import logging
from typing import Generic
import httpx
from rid_lib.ext import Cache, Bundle
from .network import NetworkInterface
from .processor import ProcessorInterface
from .processor import default_handlers
from .processor.handler import KnowledgeHandler
from .identity import NodeIdentity
from .protocol.event import Event, EventType
from .config import ConfigType

logger = logging.getLogger(__name__)



class NodeInterface(Generic[ConfigType]):
    config: ConfigType
    cache: Cache
    identity: NodeIdentity
    network: NetworkInterface
    processor: ProcessorInterface
    
    use_kobj_processor_thread: bool
    
    def __init__(
        self, 
        config: ConfigType,
        use_kobj_processor_thread: bool = False,
        
        handlers: list[KnowledgeHandler] | None = None,
        
        cache: Cache | None = None,
        network: NetworkInterface | None = None,
        processor: ProcessorInterface | None = None
    ):
        self.config: ConfigType = config
        self.cache = cache or Cache(
            self.config.koi_net.cache_directory_path)
        
        self.identity = NodeIdentity(
            config=self.config,
            cache=self.cache)
        
        self.network = network or NetworkInterface(
            config=self.config,
            cache=self.cache, 
            identity=self.identity
        )
        
        # pull all handlers defined in default_handlers module
        if handlers is None:
            handlers = [
                obj for obj in vars(default_handlers).values() 
                if isinstance(obj, KnowledgeHandler)
            ]

        self.use_kobj_processor_thread = use_kobj_processor_thread
        self.processor = processor or ProcessorInterface(
            config=self.config,
            cache=self.cache, 
            network=self.network, 
            identity=self.identity, 
            use_kobj_processor_thread=self.use_kobj_processor_thread,
            default_handlers=handlers
        )
            
    def start(self) -> None:
        """Starts a node, call this method first.
        
        Starts the processor thread (if enabled). Loads event queues into memory. Generates network graph from nodes and edges in cache. Processes any state changes of node bundle. Initiates handshake with first contact (if provided) if node doesn't have any neighbors.
        """
        if self.use_kobj_processor_thread:
            logger.info("Starting processor worker thread")
            self.processor.worker_thread.start()
        
        self.network._load_event_queues()
        self.network.graph.generate()
        
        self.processor.handle(
            bundle=Bundle.generate(
                rid=self.identity.rid, 
                contents=self.identity.profile.model_dump()
            )
        )
        
        logger.debug("Waiting for kobj queue to empty")
        if self.use_kobj_processor_thread:
            self.processor.kobj_queue.join()
        else:
            self.processor.flush_kobj_queue()
        logger.debug("Done")
    
        if not self.network.graph.get_neighbors() and self.config.koi_net.first_contact:
            logger.debug(f"I don't have any neighbors, reaching out to first contact {self.config.koi_net.first_contact}")
            
            events = [
                Event.from_rid(EventType.FORGET, self.identity.rid),
                Event.from_bundle(EventType.NEW, self.identity.bundle)
            ]
            
            try:
                self.network.request_handler.broadcast_events(
                    url=self.config.koi_net.first_contact,
                    events=events
                )
                
            except httpx.ConnectError:
                logger.warning("Failed to reach first contact")
                return
            
                        
    def stop(self):
        """Stops a node, call this method last.
        
        Finishes processing knowledge object queue. Saves event queues to storage.
        """
        logger.info("Stopping node...")
        
        if self.use_kobj_processor_thread:
            logger.info(f"Waiting for kobj queue to empty ({self.processor.kobj_queue.unfinished_tasks} tasks remaining)")
            self.processor.kobj_queue.join()
        else:
            self.processor.flush_kobj_queue()
        
        self.network._save_event_queues()


================================================
FILE: src/koi_net/identity.py
================================================
import logging
from rid_lib.ext.bundle import Bundle
from rid_lib.ext.cache import Cache
from rid_lib.types.koi_net_node import KoiNetNode

from .config import Config
from .protocol.node import NodeProfile

logger = logging.getLogger(__name__)

    
class NodeIdentity:
    """Represents a node's identity (RID, profile, bundle)."""
    
    config: Config    
    cache: Cache
    
    def __init__(
        self,
        config: Config,
        cache: Cache
    ):
        """Initializes node identity from a name and profile.
        
        Attempts to read identity from storage. If it doesn't already exist, a new RID is generated from the provided name, and that RID and profile are written to storage. Changes to the name or profile will update the stored identity.
        
        WARNING: If the name is changed, the RID will be overwritten which will have consequences for the rest of the network.
        """
        self.config = config
        self.cache = cache
        
    @property
    def rid(self) -> KoiNetNode:
        return self.config.koi_net.node_rid
    
    @property
    def profile(self) -> NodeProfile:
        return self.config.koi_net.node_profile 
    
    @property
    def bundle(self) -> Bundle:
        return self.cache.read(self.rid)


================================================
FILE: src/koi_net/network/__init__.py
================================================
from .interface import NetworkInterface


================================================
FILE: src/koi_net/network/graph.py
================================================
import logging
from typing import Literal
import networkx as nx
from rid_lib import RIDType
from rid_lib.ext import Cache
from rid_lib.types import KoiNetEdge, KoiNetNode
from ..identity import NodeIdentity
from ..protocol.edge import EdgeProfile, EdgeStatus
from ..protocol.node import NodeProfile

logger = logging.getLogger(__name__)


class NetworkGraph:
    """Graph functions for this node's view of its network."""
    
    cache: Cache
    identity: NodeIdentity
    dg: nx.DiGraph
    
    def __init__(self, cache: Cache, identity: NodeIdentity):
        self.cache = cache
        self.dg = nx.DiGraph()
        self.identity = identity
        
    def generate(self):
        """Generates directed graph from cached KOI nodes and edges."""
        logger.debug("Generating network graph")
        self.dg.clear()
        for rid in self.cache.list_rids():
            if type(rid) == KoiNetNode:                
                self.dg.add_node(rid)
                logger.debug(f"Added node {rid}")
                
            elif type(rid) == KoiNetEdge:
                edge_profile = self.get_edge_profile(rid)
                if not edge_profile:
                    logger.warning(f"Failed to load {rid!r}")
                    continue
                self.dg.add_edge(edge_profile.source, edge_profile.target, rid=rid)
                logger.debug(f"Added edge {rid} ({edge_profile.source} -> {edge_profile.target})")
        logger.debug("Done")
        
    def get_node_profile(self, rid: KoiNetNode) -> NodeProfile | None:
        """Returns node profile given its RID."""
        bundle = self.cache.read(rid)
        if bundle:
            return bundle.validate_contents(NodeProfile)
        
    def get_edge_profile(
        self, 
        rid: KoiNetEdge | None = None,
        source: KoiNetNode | None = None, 
        target: KoiNetNode | None = None,
    ) -> EdgeProfile | None:
        """Returns edge profile given its RID, or source and target node RIDs."""
        if source and target:
            if (source, target) not in self.dg.edges: return
            edge_data = self.dg.get_edge_data(source, target)
            if not edge_data: return
            rid = edge_data.get("rid")
            if not rid: return
        elif not rid:
            raise ValueError("Either 'rid' or 'source' and 'target' must be provided")
        
        bundle = self.cache.read(rid)
        if bundle:
            return bundle.validate_contents(EdgeProfile)
        
    def get_edges(
        self,
        direction: Literal["in", "out"] | None = None,
    ) -> list[KoiNetEdge]:
        """Returns edges this node belongs to.
        
        All edges returned by default, specify `direction` to restrict to incoming or outgoing edges only."""
                
        edges = []
        if direction != "in" and self.dg.out_edges:
            out_edges = self.dg.out_edges(self.identity.rid)
            edges.extend([e for e in out_edges])
                
        if direction != "out" and self.dg.in_edges:
            in_edges = self.dg.in_edges(self.identity.rid)
            edges.extend([e for e in in_edges])
                    
        edge_rids = []
        for edge in edges:
            edge_data = self.dg.get_edge_data(*edge)
            if not edge_data: continue
            edge_rid = edge_data.get("rid")
            if not edge_rid: continue
            edge_rids.append(edge_rid)
       
        return edge_rids
    
    def get_neighbors(
        self,
        direction: Literal["in", "out"] | None = None,
        status: EdgeStatus | None = None,
        allowed_type: RIDType | None = None
    ) -> list[KoiNetNode]:
        """Returns neighboring nodes this node shares an edge with.
        
        All neighboring nodes returned by default, specify `direction` to restrict to neighbors connected by incoming or outgoing edges only."""
        
        neighbors = []
        for edge_rid in self.get_edges(direction):
            edge_profile = self.get_edge_profile(edge_rid)
            
            if not edge_profile: 
                logger.warning(f"Failed to find edge {edge_rid!r} in cache")
                continue
                        
            if status and edge_profile.status != status:
                continue
            
            if allowed_type and allowed_type not in edge_profile.rid_types:
                continue
            
            if edge_profile.target == self.identity.rid:
                neighbors.append(edge_profile.source)
            elif edge_profile.source == self.identity.rid:
                neighbors.append(edge_profile.target)
                
        return list(neighbors)
        



================================================
FILE: src/koi_net/network/interface.py
================================================
import logging
from queue import Queue
from typing import Generic
import httpx
from pydantic import BaseModel
from rid_lib import RID
from rid_lib.core import RIDType
from rid_lib.ext import Cache
from rid_lib.types import KoiNetNode

from .graph import NetworkGraph
from .request_handler import RequestHandler
from .response_handler import ResponseHandler
from ..protocol.node import NodeType
from ..protocol.edge import EdgeType
from ..protocol.event import Event
from ..identity import NodeIdentity
from ..config import Config, ConfigType

logger = logging.getLogger(__name__)


class EventQueueModel(BaseModel):
    webhook: dict[KoiNetNode, list[Event]]
    poll: dict[KoiNetNode, list[Event]]

type EventQueue = dict[RID, Queue[Event]]

class NetworkInterface(Generic[ConfigType]):
    """A collection of functions and classes to interact with the KOI network."""
    
    config: ConfigType    
    identity: NodeIdentity
    cache: Cache
    graph: NetworkGraph
    request_handler: RequestHandler
    response_handler: ResponseHandler
    poll_event_queue: EventQueue
    webhook_event_queue: EventQueue
    
    def __init__(
        self, 
        config: ConfigType,
        cache: Cache, 
        identity: NodeIdentity
    ):
        self.config = config
        self.identity = identity
        self.cache = cache
        self.graph = NetworkGraph(cache, identity)
        self.request_handler = RequestHandler(cache, self.graph)
        self.response_handler = ResponseHandler(cache)
        
        self.poll_event_queue = dict()
        self.webhook_event_queue = dict()
        self._load_event_queues()
    
    def _load_event_queues(self):
        """Loads event queues from storage."""
        try:
            with open(self.config.koi_net.event_queues_path, "r") as f:
                queues = EventQueueModel.model_validate_json(f.read())
            
            for node in queues.poll.keys():
                for event in queues.poll[node]:
                    queue = self.poll_event_queue.setdefault(node, Queue())
                    queue.put(event)
            
            for node in queues.webhook.keys():
                for event in queues.webhook[node]:
                    queue = self.webhook_event_queue.setdefault(node, Queue())
                    queue.put(event)
                                
        except FileNotFoundError:
            return
        
    def _save_event_queues(self):
        """Writes event queues to storage."""
        events_model = EventQueueModel(
            poll={
                node: list(queue.queue) 
                for node, queue in self.poll_event_queue.items()
                if not queue.empty()
            },
            webhook={
                node: list(queue.queue) 
                for node, queue in self.webhook_event_queue.items()
                if not queue.empty()
            }
        )
        
        if len(events_model.poll) == 0 and len(events_model.webhook) == 0:
            return
        
        with open(self.config.koi_net.event_queues_path, "w") as f:
            f.write(events_model.model_dump_json(indent=2))
    
    def push_event_to(self, event: Event, node: KoiNetNode, flush=False):
        """Pushes event to queue of specified node.
        
        Event will be sent to webhook or poll queue depending on the node type and edge type of the specified node. If `flush` is set to `True`, the webhook queued will be flushed after pushing the event.
        """
        logger.debug(f"Pushing event {event.event_type} {event.rid} to {node}")
            
        node_profile = self.graph.get_node_profile(node)
        if not node_profile:
            logger.warning(f"Node {node!r} unknown to me")
        
        # if there's an edge from me to the target node, override broadcast type
        edge_profile = self.graph.get_edge_profile(
            source=self.identity.rid,
            target=node
        )
        
        if edge_profile:
            if edge_profile.edge_type == EdgeType.WEBHOOK:
                event_queue = self.webhook_event_queue
            elif edge_profile.edge_type == EdgeType.POLL:
                event_queue = self.poll_event_queue
        else:
            if node_profile.node_type == NodeType.FULL:
                event_queue = self.webhook_event_queue
            elif node_profile.node_type == NodeType.PARTIAL:
                event_queue = self.poll_event_queue
        
        queue = event_queue.setdefault(node, Queue())
        queue.put(event)
                
        if flush and event_queue is self.webhook_event_queue:
            self.flush_webhook_queue(node)
            
    def _flush_queue(self, event_queue: EventQueue, node: KoiNetNode) -> list[Event]:
        """Flushes a node's queue, returning list of events."""
        queue = event_queue.get(node)
        events = list()
        if queue:
            while not queue.empty():
                event = queue.get()
                logger.debug(f"Dequeued {event.event_type} '{event.rid}'")
                events.append(event)
        
        return events
    
    def flush_poll_queue(self, node: KoiNetNode) -> list[Event]:
        """Flushes a node's poll queue, returning list of events."""
        logger.debug(f"Flushing poll queue for {node}")
        return self._flush_queue(self.poll_event_queue, node)
    
    def flush_webhook_queue(self, node: KoiNetNode):
        """Flushes a node's webhook queue, and broadcasts events.
        
        If node profile is unknown, or node type is not `FULL`, this operation will fail silently. If the remote node cannot be reached, all events will be requeued.
        """
        
        logger.debug(f"Flushing webhook queue for {node}")
        
        node_profile = self.graph.get_node_profile(node)
        
        if not node_profile:
            logger.warning(f"{node!r} not found")
            return
        
        if node_profile.node_type != NodeType.FULL:
            logger.warning(f"{node!r} is a partial node!")
            return
        
        events = self._flush_queue(self.webhook_event_queue, node)
        if not events: return
        
        logger.debug(f"Broadcasting {len(events)} events")
        
        try:  
            self.request_handler.broadcast_events(node, events=events)
            return True
        except httpx.ConnectError:
            logger.warning("Broadcast failed, dropping node")
            for event in events:
                self.push_event_to(event, node)
            return False
            
    def get_state_providers(self, rid_type: RIDType) -> list[KoiNetNode]:
        """Returns list of node RIDs which provide state for the specified RID type."""
        
        logger.debug(f"Looking for state providers of '{rid_type}'")
        provider_nodes = []
        for node_rid in self.cache.list_rids(rid_types=[KoiNetNode]):
            node = self.graph.get_node_profile(node_rid)
                        
            if node.node_type == NodeType.FULL and rid_type in node.provides.state:
                logger.debug(f"Found provider '{node_rid}'")
                provider_nodes.append(node_rid)
        
        if not provider_nodes:
            logger.debug("Failed to find providers")
        return provider_nodes
            
    def fetch_remote_bundle(self, rid: RID):
        """Attempts to fetch a bundle by RID from known peer nodes."""
        
        logger.debug(f"Fetching remote bundle '{rid}'")
        remote_bundle = None
        for node_rid in self.get_state_providers(type(rid)):
            payload = self.request_handler.fetch_bundles(
                node=node_rid, rids=[rid])
            
            if payload.bundles:
                remote_bundle = payload.bundles[0]
                logger.debug(f"Got bundle from '{node_rid}'")
                break
        
        if not remote_bundle:
            logger.warning("Failed to fetch remote bundle")
            
        return remote_bundle
    
    def fetch_remote_manifest(self, rid: RID):
        """Attempts to fetch a manifest by RID from known peer nodes."""
        
        logger.debug(f"Fetching remote manifest '{rid}'")
        remote_manifest = None
        for node_rid in self.get_state_providers(type(rid)):
            payload = self.request_handler.fetch_manifests(
                node=node_rid, rids=[rid])
            
            if payload.manifests:
                remote_manifest = payload.manifests[0]
                logger.debug(f"Got bundle from '{node_rid}'")
                break
        
        if not remote_manifest:
            logger.warning("Failed to fetch remote bundle")
            
        return remote_manifest
    
    def poll_neighbors(self) -> list[Event]:
        """Polls all neighboring nodes and returns compiled list of events.
        
        If this node has no neighbors, it will instead attempt to poll the provided first contact URL.
        """
        
        neighbors = self.graph.get_neighbors()
        
        if not neighbors and self.config.koi_net.first_contact:
            logger.debug("No neighbors found, polling first contact")
            try:
                payload = self.request_handler.poll_events(
                    url=self.config.koi_net.first_contact, 
                    rid=self.identity.rid
                )
                if payload.events:
                    logger.debug(f"Received {len(payload.events)} events from '{self.config.koi_net.first_contact}'")
                return payload.events
            except httpx.ConnectError:
                logger.debug(f"Failed to reach first contact '{self.config.koi_net.first_contact}'")
        
        events = []
        for node_rid in neighbors:
            node = self.graph.get_node_profile(node_rid)
            if not node: continue
            if node.node_type != NodeType.FULL: continue
            
            try:
                payload = self.request_handler.poll_events(
                    node=node_rid, 
                    rid=self.identity.rid
                )
                if payload.events:
                    logger.debug(f"Received {len(payload.events)} events from {node_rid!r}")
                events.extend(payload.events)
            except httpx.ConnectError:
                logger.debug(f"Failed to reach node '{node_rid}'")
                continue
            
        return events                
        
        


================================================
FILE: src/koi_net/network/request_handler.py
================================================
import logging
import httpx
from rid_lib import RID
from rid_lib.ext import Cache
from rid_lib.types.koi_net_node import KoiNetNode
from ..protocol.api_models import (
    RidsPayload,
    ManifestsPayload,
    BundlesPayload,
    EventsPayload,
    FetchRids,
    FetchManifests,
    FetchBundles,
    PollEvents,
    RequestModels,
    ResponseModels
)
from ..protocol.consts import (
    BROADCAST_EVENTS_PATH,
    POLL_EVENTS_PATH,
    FETCH_RIDS_PATH,
    FETCH_MANIFESTS_PATH,
    FETCH_BUNDLES_PATH
)
from ..protocol.node import NodeType
from .graph import NetworkGraph


logger = logging.getLogger(__name__)


class RequestHandler:
    """Handles making requests to other KOI nodes."""
    
    cache: Cache
    graph: NetworkGraph
    
    def __init__(self, cache: Cache, graph: NetworkGraph):
        self.cache = cache
        self.graph = graph
                
    def make_request(
        self, 
        url: str, 
        request: RequestModels,
        response_model: type[ResponseModels] | None = None
    ) -> ResponseModels | None:
        logger.debug(f"Making request to {url}")
        resp = httpx.post(
            url=url,
            data=request.model_dump_json()
        )
        if response_model:
            return response_model.model_validate_json(resp.text)
            
    def get_url(self, node_rid: KoiNetNode, url: str) -> str:
        """Retrieves URL of a node, or returns provided URL."""
        
        if not node_rid and not url:
            raise ValueError("One of 'node_rid' and 'url' must be provided")
        
        if node_rid:
            node_profile = self.graph.get_node_profile(node_rid)
            if not node_profile:
                raise Exception("Node not found")
            if node_profile.node_type != NodeType.FULL:
                raise Exception("Can't query partial node")
            logger.debug(f"Resolved {node_rid!r} to {node_profile.base_url}")
            return node_profile.base_url
        else:
            return url
    
    def broadcast_events(
        self, 
        node: RID = None, 
        url: str = None, 
        req: EventsPayload | None = None,
        **kwargs
    ) -> None:
        """See protocol.api_models.EventsPayload for available kwargs."""
        request = req or EventsPayload.model_validate(kwargs)
        self.make_request(
            self.get_url(node, url) + BROADCAST_EVENTS_PATH, request
        )
        logger.info(f"Broadcasted {len(request.events)} event(s) to {node or url!r}")
        
    def poll_events(
        self, 
        node: RID = None, 
        url: str = None, 
        req: PollEvents | None = None,
        **kwargs
    ) -> EventsPayload:
        """See protocol.api_models.PollEvents for available kwargs."""
        request = req or PollEvents.model_validate(kwargs)
        resp = self.make_request(
            self.get_url(node, url) + POLL_EVENTS_PATH, request,
            response_model=EventsPayload
        )
        logger.info(f"Polled {len(resp.events)} events from {node or url!r}")
        return resp
        
    def fetch_rids(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchRids | None = None,
        **kwargs
    ) -> RidsPayload:
        """See protocol.api_models.FetchRids for available kwargs."""
        request = req or FetchRids.model_validate(kwargs)
        resp = self.make_request(
            self.get_url(node, url) + FETCH_RIDS_PATH, request,
            response_model=RidsPayload
        )
        logger.info(f"Fetched {len(resp.rids)} RID(s) from {node or url!r}")
        return resp
                
    def fetch_manifests(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchManifests | None = None,
        **kwargs
    ) -> ManifestsPayload:
        """See protocol.api_models.FetchManifests for available kwargs."""
        request = req or FetchManifests.model_validate(kwargs)
        resp = self.make_request(
            self.get_url(node, url) + FETCH_MANIFESTS_PATH, request,
            response_model=ManifestsPayload
        )
        logger.info(f"Fetched {len(resp.manifests)} manifest(s) from {node or url!r}")
        return resp
                
    def fetch_bundles(
        self, 
        node: RID = None, 
        url: str = None, 
        req: FetchBundles | None = None,
        **kwargs
    ) -> BundlesPayload:
        """See protocol.api_models.FetchBundles for available kwargs."""
        request = req or FetchBundles.model_validate(kwargs)
        resp = self.make_request(
            self.get_url(node, url) + FETCH_BUNDLES_PATH, request,
            response_model=BundlesPayload
        )
        logger.info(f"Fetched {len(resp.bundles)} bundle(s) from {node or url!r}")
        return resp


================================================
FILE: src/koi_net/network/response_handler.py
================================================
import logging
from rid_lib import RID
from rid_lib.ext import Manifest, Cache
from rid_lib.ext.bundle import Bundle
from ..protocol.api_models import (
    RidsPayload,
    ManifestsPayload,
    BundlesPayload,
    FetchRids,
    FetchManifests,
    FetchBundles,
)

logger = logging.getLogger(__name__)


class ResponseHandler:
    """Handles generating responses to requests from other KOI nodes."""
    
    cache: Cache
    
    def __init__(self, cache: Cache):
        self.cache = cache
        
    def fetch_rids(self, req: FetchRids) -> RidsPayload:
        logger.info(f"Request to fetch rids, allowed types {req.rid_types}")
        rids = self.cache.list_rids(req.rid_types)
        
        return RidsPayload(rids=rids)
        
    def fetch_manifests(self, req: FetchManifests) -> ManifestsPayload:
        logger.info(f"Request to fetch manifests, allowed types {req.rid_types}, rids {req.rids}")
        
        manifests: list[Manifest] = []
        not_found: list[RID] = []
        
        for rid in (req.rids or self.cache.list_rids(req.rid_types)):
            bundle = self.cache.read(rid)
            if bundle:
                manifests.append(bundle.manifest)
            else:
                not_found.append(rid)
        
        return ManifestsPayload(manifests=manifests, not_found=not_found)
        
    def fetch_bundles(self, req: FetchBundles) -> BundlesPayload:
        logger.info(f"Request to fetch bundles, requested rids {req.rids}")
        
        bundles: list[Bundle] = []
        not_found: list[RID] = []

        for rid in req.rids:
            bundle = self.cache.read(rid)
            if bundle:
                bundles.append(bundle)
            else:
                not_found.append(rid)
            
        return BundlesPayload(bundles=bundles, not_found=not_found)


================================================
FILE: src/koi_net/processor/__init__.py
================================================
from .interface import ProcessorInterface


================================================
FILE: src/koi_net/processor/default_handlers.py
================================================
"""Provides implementations of default knowledge handlers."""

import logging
from rid_lib.ext.bundle import Bundle
from rid_lib.types import KoiNetNode, KoiNetEdge
from koi_net.protocol.node import NodeType
from .interface import ProcessorInterface
from .handler import KnowledgeHandler, HandlerType, STOP_CHAIN
from .knowledge_object import KnowledgeObject, KnowledgeSource
from ..protocol.event import Event, EventType
from ..protocol.edge import EdgeProfile, EdgeStatus, EdgeType

logger = logging.getLogger(__name__)

# RID handlers

@KnowledgeHandler.create(HandlerType.RID)
def basic_rid_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    """Default RID handler.
    
    Blocks external events about this node. Allows `FORGET` events if RID is known to this node.
    """
    if (kobj.rid == processor.identity.rid and 
        kobj.source == KnowledgeSource.External):
        logger.debug("Don't let anyone else tell me who I am!")
        return STOP_CHAIN
    
    if kobj.event_type == EventType.FORGET:
        kobj.normalized_event_type = EventType.FORGET
        return kobj

# Manifest handlers

@KnowledgeHandler.create(HandlerType.Manifest)
def basic_manifest_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    """Default manifest handler.
    
    Blocks manifests with the same hash, or aren't newer than the cached version. Sets the normalized event type to `NEW` or `UPDATE` depending on whether the RID was previously known to this node.
    """
    prev_bundle = processor.cache.read(kobj.rid)

    if prev_bundle:
        if kobj.manifest.sha256_hash == prev_bundle.manifest.sha256_hash:
            logger.debug("Hash of incoming manifest is same as existing knowledge, ignoring")
            return STOP_CHAIN
        if kobj.manifest.timestamp <= prev_bundle.manifest.timestamp:
            logger.debug("Timestamp of incoming manifest is the same or older than existing knowledge, ignoring")
            return STOP_CHAIN
        
        logger.debug("RID previously known to me, labeling as 'UPDATE'")
        kobj.normalized_event_type = EventType.UPDATE

    else:
        logger.debug("RID previously unknown to me, labeling as 'NEW'")
        kobj.normalized_event_type = EventType.NEW
        
    return kobj


# Bundle handlers

@KnowledgeHandler.create(
    handler_type=HandlerType.Bundle, 
    rid_types=[KoiNetEdge], 
    source=KnowledgeSource.External,
    event_types=[EventType.NEW, EventType.UPDATE])
def edge_negotiation_handler(processor: ProcessorInterface, kobj: KnowledgeObject):
    """Handles basic edge negotiation process.
    
    Automatically approves proposed edges if they request RID types this node can provide (or KOI nodes/edges). Validates the edge type is allowed for the node type (partial nodes cannot use webhooks). If edge is invalid, a `FORGET` event is sent to the other node.
    """
    
    edge_profile = EdgeProfile.model_validate(kobj.contents)

    # indicates peer subscribing to me
    if edge_profile.source == processor.identity.rid:     
        if edge_profile.status != EdgeStatus.PROPOSED:
            return
        
        logger.debug("Handling edge negotiation")
        
        peer_rid = edge_profile.target
        peer_profile = processor.network.graph.get_node_profile(peer_rid)
        
        if not peer_profile:
            logger.warning(f"Peer {peer_rid} unknown to me")
            return STOP_CHAIN
        
        # explicitly provided event RID types and (self) node + edge objects
        provided_events = (
            *processor.identity.profile.provides.event,
            KoiNetNode, KoiNetEdge
        )
        
        
        abort = False
        if (edge_profile.edge_type == EdgeType.WEBHOOK and 
            peer_profile.node_type == NodeType.PARTIAL):
            logger.debug("Partial nodes cannot use webhooks")
            abort = True
        
        if not set(edge_profile.rid_types).issubset(provided_events):
            logger.debug("Requested RID types not provided by this node")
            abort = True
        
        if abort:
            event = Event.from_rid(EventType.FORGET, kobj.rid)
            processor.network.push_event_to(event, peer_rid, flush=True)
            return STOP_CHAIN

        else:
            # approve edge profile
            logger.debug("Approving proposed edge")
            edge_profile.status = EdgeStatus.APPROVED
            updated_bundle = Bundle.generate(kobj.rid, edge_profile.model_dump())
      
            processor.handle(bundle=updated_bundle, event_type=EventType.UPDATE)
            return
              
    elif edge_profile.target == processor.identity.rid:
        if edge_profile.status == EdgeStatus.APPROVED:
            logger.debug("Edge approved by other node!")


# Network handlers

@KnowledgeHandler.create(HandlerType.Network)
def basic_network_output_filter(processor: ProcessorInterface, kobj: KnowledgeObject):
    """Default network handler.
    
    Allows broadcasting of all RID types this node is an event provider for (set in node profile), and other nodes have subscribed to. All nodes will also broadcast about their own (internally sourced) KOI node, and KOI edges that they are part of, regardless of their node profile configuration. Finally, nodes will also broadcast about edges to the other node involved (regardless of if they are subscribed)."""
    
    involves_me = False
    if kobj.source == KnowledgeSource.Internal:
        if (type(kobj.rid) == KoiNetNode):
            if (kobj.rid == processor.identity.rid):
                involves_me = True
        
        elif type(kobj.rid) == KoiNetEdge:
            edge_profile = kobj.bundle.validate_contents(EdgeProfile)
            
            if edge_profile.source == processor.identity.rid:
                logger.debug(f"Adding edge target '{edge_profile.target!r}' to network targets")
                kobj.network_targets.update([edge_profile.target])
                involves_me = True
                
            elif edge_profile.target == processor.identity.rid:
                logger.debug(f"Adding edge source '{edge_profile.source!r}' to network targets")
                kobj.network_targets.update([edge_profile.source])
                involves_me = True
    
    if (type(kobj.rid) in processor.identity.profile.provides.event or involves_me):
        # broadcasts to subscribers if I'm an event provider of this RID type OR it involves me
        subscribers = processor.network.graph.get_neighbors(
            direction="out",
            allowed_type=type(kobj.rid)
        )
        
        logger.debug(f"Updating network targets with '{type(kobj.rid)}' subscribers: {subscribers}")
        kobj.network_targets.update(subscribers)
        
    return kobj
            


================================================
FILE: src/koi_net/processor/handler.py
================================================
from dataclasses import dataclass
from enum import StrEnum
from typing import Callable
from rid_lib import RIDType

from ..protocol.event import EventType
from .knowledge_object import KnowledgeSource, KnowledgeEventType


class StopChain:
    """Class for a sentinel value by knowledge handlers."""
    pass

STOP_CHAIN = StopChain()


class HandlerType(StrEnum):
    """Types of handlers used in knowledge processing pipeline.
    
    - RID - provided RID; if event type is `FORGET`, this handler decides whether to delete the knowledge from the cache by setting the normalized event type to `FORGET`, otherwise this handler decides whether to validate the manifest (and fetch it if not provided).
    - Manifest - provided RID, manifest; decides whether to validate the bundle (and fetch it if not provided).
    - Bundle - provided RID, manifest, contents (bundle); decides whether to write knowledge to the cache by setting the normalized event type to `NEW` or `UPDATE`.
    - Network - provided RID, manifest, contents (bundle); decides which nodes (if any) to broadcast an event about this knowledge to. (Note, if event type is `FORGET`, the manifest and contents will be retrieved from the local cache, and indicate the last state of the knowledge before it was deleted.)
    - Final - provided RID, manifests, contents (bundle); final action taken after network broadcast.
    """
    
    RID = "rid", 
    Manifest = "manifest", 
    Bundle = "bundle", 
    Network = "network", 
    Final = "final"

@dataclass
class KnowledgeHandler:
    """Handles knowledge processing events of the provided types."""
    
    func: Callable
    handler_type: HandlerType
    rid_types: list[RIDType] | None
    source: KnowledgeSource | None = None
    event_types: list[KnowledgeEventType] | None = None
    
    @classmethod
    def create(
        cls,
        handler_type: HandlerType,
        rid_types: list[RIDType] | None = None,
        source: KnowledgeSource | None = None,
        event_types: list[KnowledgeEventType] | None = None
    ):
        """Special decorator that returns a KnowledgeHandler instead of a function.
        
        The function symbol will redefined as a `KnowledgeHandler`, which can be passed into the `ProcessorInterface` constructor. This is used to register default handlers.
        """
        def decorator(func: Callable) -> KnowledgeHandler:
            handler = cls(func, handler_type, rid_types, source, event_types)
            return handler
        return decorator




================================================
FILE: src/koi_net/processor/interface.py
================================================
import logging
import queue
import threading
from typing import Callable, Generic
from rid_lib.core import RID, RIDType
from rid_lib.ext import Bundle, Cache, Manifest
from rid_lib.types.koi_net_edge import KoiNetEdge
from rid_lib.types.koi_net_node import KoiNetNode
from ..identity import NodeIdentity
from ..network import NetworkInterface
from ..protocol.event import Event, EventType
from ..config import Config
from .handler import (
    KnowledgeHandler, 
    HandlerType, 
    STOP_CHAIN,
    StopChain
)
from .knowledge_object import (
    KnowledgeObject,
    KnowledgeSource, 
    KnowledgeEventType
)

logger = logging.getLogger(__name__)


class ProcessorInterface():
    """Provides access to this node's knowledge processing pipeline."""
    
    config: Config
    cache: Cache
    network: NetworkInterface
    identity: NodeIdentity
    handlers: list[KnowledgeHandler]
    kobj_queue: queue.Queue[KnowledgeObject]
    use_kobj_processor_thread: bool
    worker_thread: threading.Thread | None = None
    
    def __init__(
        self,
        config: Config,
        cache: Cache, 
        network: NetworkInterface,
        identity: NodeIdentity,
        use_kobj_processor_thread: bool,
        default_handlers: list[KnowledgeHandler] = []
    ):
        self.config = config
        self.cache = cache
        self.network = network
        self.identity = identity
        self.use_kobj_processor_thread = use_kobj_processor_thread
        self.handlers: list[KnowledgeHandler] = default_handlers
        self.kobj_queue = queue.Queue()
        
        if self.use_kobj_processor_thread:
            self.worker_thread = threading.Thread(
                target=self.kobj_processor_worker,
                daemon=True
            )
        
    def add_handler(self, handler: KnowledgeHandler):
        self.handlers.append(handler)
            
    def register_handler(
        self,
        handler_type: HandlerType,
        rid_types: list[RIDType] | None = None,
        source: KnowledgeSource | None = None,
        event_types: list[KnowledgeEventType] | None = None
    ):
        """Assigns decorated function as handler for this processor."""
        def decorator(func: Callable) -> Callable:
            handler = KnowledgeHandler(func, handler_type, rid_types, source, event_types)
            self.add_handler(handler)
            return func
        return decorator
            
    def call_handler_chain(
        self, 
        handler_type: HandlerType,
        kobj: KnowledgeObject
    ) -> KnowledgeObject | StopChain:
        """Calls handlers of provided type, chaining their inputs and outputs together.
        
        The knowledge object provided when this function is called will be passed to the first handler. A handler may return one of three types: 
        - `KnowledgeObject` - to modify the knowledge object for the next handler in the chain
        - `None` - to keep the same knowledge object for the next handler in the chain
        - `STOP_CHAIN` - to stop the handler chain and immediately exit the processing pipeline
        
        Handlers will only be called in the chain if their handler and RID type match that of the inputted knowledge object. 
        """
        
        for handler in self.handlers:
            if handler_type != handler.handler_type: 
                continue
            
            if handler.rid_types and type(kobj.rid) not in handler.rid_types:
                continue
            
            if handler.source and handler.source != kobj.source:
                continue
            
            if handler.event_types and kobj.event_type not in handler.event_types:
                continue
            
            logger.debug(f"Calling {handler_type} handler '{handler.func.__name__}'")
            resp = handler.func(self, kobj.model_copy())
            
            # stops handler chain execution
            if resp is STOP_CHAIN:
                logger.debug(f"Handler chain stopped by {handler.func.__name__}")
                return STOP_CHAIN
            # kobj unmodified
            elif resp is None:
                continue
            # kobj modified by handler
            elif isinstance(resp, KnowledgeObject):
                kobj = resp
                logger.debug(f"Knowledge object modified by {handler.func.__name__}")
            else:
                raise ValueError(f"Handler {handler.func.__name__} returned invalid response '{resp}'")
                    
        return kobj

        
    def process_kobj(self, kobj: KnowledgeObject) -> None:
        """Sends provided knowledge obejct through knowledge processing pipeline.
        
        Handler chains are called in between major events in the pipeline, indicated by their handler type. Each handler type is guaranteed to have access to certain knowledge, and may affect a subsequent action in the pipeline. The five handler types are as follows:
        - RID - provided RID; if event type is `FORGET`, this handler decides whether to delete the knowledge from the cache by setting the normalized event type to `FORGET`, otherwise this handler decides whether to validate the manifest (and fetch it if not provided).
        - Manifest - provided RID, manifest; decides whether to validate the bundle (and fetch it if not provided).
        - Bundle - provided RID, manifest, contents (bundle); decides whether to write knowledge to the cache by setting the normalized event type to `NEW` or `UPDATE`.
        - Network - provided RID, manifest, contents (bundle); decides which nodes (if any) to broadcast an event about this knowledge to. (Note, if event type is `FORGET`, the manifest and contents will be retrieved from the local cache, and indicate the last state of the knowledge before it was deleted.)
        - Final - provided RID, manifests, contents (bundle); final action taken after network broadcast.
        
        The pipeline may be stopped by any point by a single handler returning the `STOP_CHAIN` sentinel. In that case, the process will exit immediately. Further handlers of that type and later handler chains will not be called.
        """
        
        logger.debug(f"Handling {kobj!r}")
        kobj = self.call_handler_chain(HandlerType.RID, kobj)
        if kobj is STOP_CHAIN: return
        
        if kobj.event_type == EventType.FORGET:
            bundle = self.cache.read(kobj.rid)
            if not bundle: 
                logger.debug("Local bundle not found")
                return
            
            # the bundle (to be deleted) attached to kobj for downstream analysis
            logger.debug("Adding local bundle (to be deleted) to knowledge object")
            kobj.manifest = bundle.manifest
            kobj.contents = bundle.contents
            
        else:
            # attempt to retrieve manifest
            if not kobj.manifest:
                logger.debug("Manifest not found")
                if kobj.source == KnowledgeSource.External:
                    logger.debug("Attempting to fetch remote manifest")
                    manifest = self.network.fetch_remote_manifest(kobj.rid)
                    
                elif kobj.source == KnowledgeSource.Internal:
                    logger.debug("Attempting to read manifest from cache")
                    bundle = self.cache.read(kobj.rid)
                    if bundle: 
                        manifest = bundle.manifest
                    else:
                        manifest = None
                        return
                    
                if not manifest:
                    logger.debug("Failed to find manifest")
                    return
                
                kobj.manifest = manifest
                
            kobj = self.call_handler_chain(HandlerType.Manifest, kobj)
            if kobj is STOP_CHAIN: return
            
            # attempt to retrieve bundle
            if not kobj.bundle:
                logger.debug("Bundle not found")
                if kobj.source == KnowledgeSource.External:
                    logger.debug("Attempting to fetch remote bundle")
                    bundle = self.network.fetch_remote_bundle(kobj.rid)
                    
                elif kobj.source == KnowledgeSource.Internal:
                    logger.debug("Attempting to read bundle from cache")
                    bundle = self.cache.read(kobj.rid)
                
                if not bundle: 
                    logger.debug("Failed to find bundle")
                    return
                
                if kobj.manifest != bundle.manifest:
                    logger.warning("Retrieved bundle contains a different manifest")
                
                kobj.manifest = bundle.manifest
                kobj.contents = bundle.contents                
                
        kobj = self.call_handler_chain(HandlerType.Bundle, kobj)
        if kobj is STOP_CHAIN: return
            
        if kobj.normalized_event_type in (EventType.UPDATE, EventType.NEW):
            logger.info(f"Writing to cache: {kobj!r}")
            self.cache.write(kobj.bundle)
            
        elif kobj.normalized_event_type == EventType.FORGET:
            logger.info(f"Deleting from cache: {kobj!r}")
            self.cache.delete(kobj.rid)
            
        else:
            logger.debug("Normalized event type was never set, no cache or network operations will occur")
            return
        
        if type(kobj.rid) in (KoiNetNode, KoiNetEdge):
            logger.debug("Change to node or edge, regenerating network graph")
            self.network.graph.generate()
        
        kobj = self.call_handler_chain(HandlerType.Network, kobj)
        if kobj is STOP_CHAIN: return
        
        if kobj.network_targets:
            logger.debug(f"Broadcasting event to {len(kobj.network_targets)} network target(s)")
        else:
            logger.debug("No network targets set")
        
        for node in kobj.network_targets:
            self.network.push_event_to(kobj.normalized_event, node)
            if not self.network.flush_webhook_queue(node):
                logger.warning("Dropping unresponsive node")
                self.handle(rid=node, event_type=EventType.FORGET)
        
        kobj = self.call_handler_chain(HandlerType.Final, kobj)

    def flush_kobj_queue(self):
        """Flushes all knowledge objects from queue and processes them.
        
        NOTE: ONLY CALL THIS METHOD IN SINGLE THREADED NODES, OTHERWISE THIS WILL CAUSE RACE CONDITIONS.
        """
        if self.use_kobj_processor_thread:
            logger.warning("You are using a worker thread, calling this method can cause race conditions!")
        
        while not self.kobj_queue.empty():
            kobj = self.kobj_queue.get()
            logger.debug(f"Dequeued {kobj!r}")
            
            try:
                self.process_kobj(kobj)
            finally:
                self.kobj_queue.task_done()
            logger.debug("Done")
    
    def kobj_processor_worker(self, timeout=0.1):
        while True:
            try:
                kobj = self.kobj_queue.get(timeout=timeout)
                logger.debug(f"Dequeued {kobj!r}")
                
                try:
                    self.process_kobj(kobj)
                finally:
                    self.kobj_queue.task_done()
                logger.debug("Done")
            
            except queue.Empty:
                pass
            
            except Exception as e:
                logger.warning(f"Error processing kobj: {e}")
        
    def handle(
        self,
        rid: RID | None = None,
        manifest: Manifest | None = None,
        bundle: Bundle | None = None,
        event: Event | None = None,
        kobj: KnowledgeObject | None = None,
        event_type: KnowledgeEventType = None,
        source: KnowledgeSource = KnowledgeSource.Internal
    ):
        """Queues provided knowledge to be handled by processing pipeline.
        
        Knowledge may take the form of an RID, manifest, bundle, event, or knowledge object (with an optional event type for RID, manifest, or bundle objects). All objects will be normalized into knowledge objects and queued. If `flush` is `True`, the queue will be flushed immediately after adding the new knowledge.
        """
        if rid:
            _kobj = KnowledgeObject.from_rid(rid, event_type, source)
        elif manifest:
            _kobj = KnowledgeObject.from_manifest(manifest, event_type, source)
        elif bundle:
            _kobj = KnowledgeObject.from_bundle(bundle, event_type, source)
        elif event:
            _kobj = KnowledgeObject.from_event(event, source)
        elif kobj:
            _kobj = kobj
        else:
            raise ValueError("One of 'rid', 'manifest', 'bundle', 'event', or 'kobj' must be provided")
        
        self.kobj_queue.put(_kobj)
        logger.debug(f"Queued {_kobj!r}")



================================================
FILE: src/koi_net/processor/knowledge_object.py
================================================
from enum import StrEnum
from pydantic import BaseModel
from rid_lib import RID
from rid_lib.ext import Manifest
from rid_lib.ext.bundle import Bundle
from rid_lib.types.koi_net_node import KoiNetNode
from ..protocol.event import Event, EventType


type KnowledgeEventType = EventType | None

class KnowledgeSource(StrEnum):
    Internal = "INTERNAL"
    External = "EXTERNAL"

class KnowledgeObject(BaseModel):
    """A normalized knowledge representation for internal processing.
    
    Capable of representing an RID, manifest, bundle, or event. Contains three additional fields use for decision making in the knowledge processing pipeline. 
    
    The source indicates whether this object was generated by this node, or sourced from another node in the network. 
    
    The normalized event type indicates how the knowledge object is viewed from the perspective of this node, and what cache actions will take place. `NEW`, `UPDATE` -> cache write, `FORGET` -> cache delete, `None` -> no cache action.
    
    The network targets indicate other nodes in the network this knowledge object will be sent to. The event sent to them will be constructed from this knowledge object's RID, manifest, contents, and normalized event type.
    
    Constructors are provided to create a knowledge object from an RID, manifest, bundle, or event.
    """
    rid: RID
    manifest: Manifest | None = None
    contents: dict | None = None
    event_type: KnowledgeEventType = None
    normalized_event_type: KnowledgeEventType = None
    source: KnowledgeSource
    network_targets: set[KoiNetNode] = set()
    
    def __repr__(self):
        return f"<KObj '{self.rid}' event type: '{self.event_type}' -> '{self.normalized_event_type}', source: '{self.source}'>"
    
    @classmethod
    def from_rid(
        cls, 
        rid: RID, 
        event_type: KnowledgeEventType = None, 
        source: KnowledgeSource = KnowledgeSource.Internal
    ) -> "KnowledgeObject":
        return cls(
            rid=rid,
            event_type=event_type,
            source=source
        )
        
    @classmethod
    def from_manifest(
        cls, 
        manifest: Manifest, 
        event_type: KnowledgeEventType = None, 
        source: KnowledgeSource = KnowledgeSource.Internal
    ) -> "KnowledgeObject":
        return cls(
            rid=manifest.rid,
            manifest=manifest,
            event_type=event_type,
            source=source
        )
        
    @classmethod
    def from_bundle(
        cls, 
        bundle: Bundle, 
        event_type: KnowledgeEventType = None, 
        source: KnowledgeSource = KnowledgeSource.Internal
    ) -> "KnowledgeObject":
        return cls(
            rid=bundle.rid,
            manifest=bundle.manifest,
            contents=bundle.contents,
            event_type=event_type,
            source=source
        )
        
    @classmethod
    def from_event(
        cls,
        event: Event,
        source: KnowledgeSource = KnowledgeSource.Internal
    ) -> "KnowledgeObject":
        return cls(
            rid=event.rid,
            manifest=event.manifest,
            contents=event.contents,
            event_type=event.event_type,
            source=source
        )
    
    @property
    def bundle(self):
        if self.manifest is None or self.contents is None:
            return
        
        return Bundle(
            manifest=self.manifest,
            contents=self.contents
        )
    
    @property
    def normalized_event(self):
        if self.normalized_event_type is None:
            raise ValueError("Internal event's normalized event type is None, cannot convert to Event")
        
        elif self.normalized_event_type == EventType.FORGET:
            return Event(
                rid=self.rid,
                event_type=EventType.FORGET
            )
        
        else:    
            return Event(
                rid=self.rid,
                event_type=self.normalized_event_type,
                manifest=self.manifest,
                contents=self.contents
            )


================================================
FILE: src/koi_net/protocol/__init__.py
================================================



================================================
FILE: src/koi_net/protocol/api_models.py
================================================
"""Pydantic models for request and response/payload objects in the KOI-net API."""

from pydantic import BaseModel
from rid_lib import RID, RIDType
from rid_lib.ext import Bundle, Manifest
from .event import Event


# REQUEST MODELS

class PollEvents(BaseModel):
    rid: RID
    limit: int = 0
    
class FetchRids(BaseModel):
    rid_types: list[RIDType] = []
    
class FetchManifests(BaseModel):
    rid_types: list[RIDType] = []
    rids: list[RID] = []
    
class FetchBundles(BaseModel):
    rids: list[RID]
    

# RESPONSE/PAYLOAD MODELS

class RidsPayload(BaseModel):
    rids: list[RID]

class ManifestsPayload(BaseModel):
    manifests: list[Manifest]
    not_found: list[RID] = []
    
class BundlesPayload(BaseModel):
    bundles: list[Bundle]
    not_found: list[RID] = []
    deferred: list[RID] = []
    
class EventsPayload(BaseModel):
    events: list[Event]
    

# TYPES

type RequestModels = EventsPayload | PollEvents | FetchRids | FetchManifests | FetchBundles
type ResponseModels = RidsPayload | ManifestsPayload | BundlesPayload | EventsPayload


================================================
FILE: src/koi_net/protocol/consts.py
================================================
"""API paths for KOI-net protocol."""

BROADCAST_EVENTS_PATH = "/events/broadcast"
POLL_EVENTS_PATH      = "/events/poll"
FETCH_RIDS_PATH       = "/rids/fetch"
FETCH_MANIFESTS_PATH  = "/manifests/fetch"
FETCH_BUNDLES_PATH    = "/bundles/fetch"


================================================
FILE: src/koi_net/protocol/edge.py
================================================
from enum import StrEnum
from pydantic import BaseModel
from rid_lib import RIDType
from rid_lib.types import KoiNetNode


class EdgeStatus(StrEnum):
    PROPOSED = "PROPOSED"
    APPROVED = "APPROVED"
    
class EdgeType(StrEnum):
    WEBHOOK = "WEBHOOK"
    POLL = "POLL"

class EdgeProfile(BaseModel):
    source: KoiNetNode
    target: KoiNetNode
    edge_type: EdgeType
    status: EdgeStatus
    rid_types: list[RIDType]



================================================
FILE: src/koi_net/protocol/event.py
================================================
from enum import StrEnum
from pydantic import BaseModel
from rid_lib import RID
from rid_lib.ext import Manifest, Bundle


class EventType(StrEnum):
    NEW = "NEW"
    UPDATE = "UPDATE"
    FORGET = "FORGET"

class Event(BaseModel):
    rid: RID
    event_type: EventType
    manifest: Manifest | None = None
    contents: dict | None = None
    
    def __repr__(self):
        return f"<Event '{self.rid}' event type: '{self.event_type}'>"
    
    @classmethod
    def from_bundle(cls, event_type: EventType, bundle: Bundle):
        return cls(
            rid=bundle.manifest.rid,
            event_type=event_type,
            manifest=bundle.manifest,
            contents=bundle.contents
        )
        
    @classmethod
    def from_manifest(cls, event_type: EventType, manifest: Manifest):
        return cls(
            rid=manifest.rid,
            event_type=event_type,
            manifest=manifest
        )
        
    @classmethod
    def from_rid(cls, event_type: EventType, rid: RID):
        return cls(
            rid=rid,
            event_type=event_type
        )
        
    @property
    def bundle(self):
        if self.manifest is not None and self.contents is not None:
            return Bundle(
                manifest=self.manifest,
                contents=self.contents
            )


================================================
FILE: src/koi_net/protocol/helpers.py
================================================
from rid_lib.core import RIDType
from rid_lib.ext.bundle import Bundle
from rid_lib.types import KoiNetEdge
from rid_lib.types.koi_net_node import KoiNetNode
from .edge import EdgeProfile, EdgeStatus, EdgeType

def generate_edge_bundle(
    source: KoiNetNode,
    target: KoiNetNode,
    rid_types: list[RIDType],
    edge_type: EdgeType
) -> Bundle:
    edge_rid = KoiNetEdge.generate(source, target)
    edge_profile = EdgeProfile(
        source=source,
        target=target,
        rid_types=rid_types,
        edge_type=edge_type,
        status=EdgeStatus.PROPOSED
    )
    edge_bundle = Bundle.generate(
        edge_rid,
        edge_profile.model_dump()
    )
    return edge_bundle


================================================
FILE: src/koi_net/protocol/node.py
================================================
from enum import StrEnum
from pydantic import BaseModel
from rid_lib import RIDType


class NodeType(StrEnum):
    FULL = "FULL"
    PARTIAL = "PARTIAL"

class NodeProvides(BaseModel):
    event: list[RIDType] = []
    state: list[RIDType] = []

class NodeProfile(BaseModel):
    base_url: str | None = None
    node_type: NodeType
    provides: NodeProvides = NodeProvides()


================================================
FILE: .github/workflows/publish-to-pypi.yml
================================================
name: Publish Python package to PyPI
on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build:
    name: Build distro
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        persistent-credentials: false
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.x"
    - name: Install pypa/build
      run: python3 -m pip install build --user
    - name: Build a binary wheel and a source tarball
      run: python3 -m build
    - name: Store the distribution packages
      uses: actions/upload-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
  
  publish-to-pypi:
    name: Publish Python distribution to PyPI
    if: startsWith(github.ref, 'refs/tags/')
    needs:
    - build
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/koi-net
    permissions:
      id-token: write

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distro to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

  github-release:
    name: >-
      Sign the Python distribution with Sigstore
      and upload them to GitHub Release
    needs:
    - publish-to-pypi
    runs-on: ubuntu-latest

    permissions:
      contents: write
      id-token: write

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Sign the dists with Sigstore
      uses: sigstore/gh-action-sigstore-python@v3.0.0
      with:
        inputs: >-
          ./dist/*.tar.gz
          ./dist/*.whl
    - name: Upload artifact signatures to GitHub Release
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: >-
        gh release upload
        "$GITHUB_REF_NAME" dist/**
        --repo "$GITHUB_REPOSITORY"



================================================
REPO: blockscience/rid-lib
================================================

</file_summary>

<directory_structure>
ext/
  __init__.py
  bundle.py
  cache.py
  effector.py
  manifest.py
  utils.py
types/
  __init__.py
  http_s.py
  koi_net_edge.py
  koi_net_node.py
  slack_channel.py
  slack_message.py
  slack_user.py
  slack_workspace.py
__init__.py
consts.py
core.py
README.md
utils.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ext/__init__.py">
from .manifest import Manifest
from .bundle import Bundle
from .cache import Cache
from .effector import ActionType, Effector
</file>

<file path="ext/bundle.py">
from typing import TypeVar
from pydantic import BaseModel
from rid_lib.core import RID
from .manifest import Manifest


T = TypeVar("T", bound=BaseModel)

class Bundle(BaseModel):
    """A knowledge bundle composed of a manifest and contents associated with an RIDed object.

    Acts as a container for the data associated with an RID. It is written to and read from the cache.
    """
    manifest: Manifest
    contents: dict
    
    @classmethod
    def generate(cls, rid: RID, contents: dict) -> "Bundle":
        """Generates a bundle from provided RID and contents."""
        return cls(
            manifest=Manifest.generate(rid, contents),
            contents=contents
        )
    
    @property
    def rid(self):
        """This bundle's RID."""
        return self.manifest.rid
    
    def validate_contents(self, model: type[T]) -> T:
        """Attempts to validate contents against a Pydantic model."""
        return model.model_validate(self.contents)
</file>

<file path="ext/cache.py">
import os
import shutil
from rid_lib.core import RID, RIDType
from .bundle import Bundle
from .utils import b64_encode, b64_decode


class Cache:
    def __init__(self, directory_path: str):
        self.directory_path = directory_path
        
    def file_path_to(self, rid: RID) -> str:
        encoded_rid_str = b64_encode(str(rid))
        return f"{self.directory_path}/{encoded_rid_str}.json"

    def write(self, cache_bundle: Bundle) -> Bundle:
        """Writes bundle to cache, returns a Bundle."""
        if not os.path.exists(self.directory_path):
            os.makedirs(self.directory_path)
            
        with open(
            file=self.file_path_to(cache_bundle.manifest.rid), 
            mode="w", 
            encoding="utf-8"
        ) as f:
            f.write(cache_bundle.model_dump_json(indent=2))

        return cache_bundle
    
    def exists(self, rid: RID) -> bool:
        return os.path.exists(
            self.file_path_to(rid)
        )

    def read(self, rid: RID) -> Bundle | None:
        """Reads and returns CacheEntry from RID cache."""
        try:
            with open(
                file=self.file_path_to(rid), 
                mode="r",
                encoding="utf-8"
            ) as f:
                return Bundle.model_validate_json(f.read())
        except FileNotFoundError:
            return None
    
    def list_rids(self, rid_types: list[RIDType] | None = None) -> list[RID]:
        if not os.path.exists(self.directory_path):
            return []
        
        rids = []
        for filename in os.listdir(self.directory_path):
            encoded_rid_str = filename.split(".")[0]
            rid_str = b64_decode(encoded_rid_str)
            rid = RID.from_string(rid_str)
            
            if not rid_types or type(rid) in rid_types:
                rids.append(rid)
            
        return rids
                
    def delete(self, rid: RID) -> None:
        """Deletes cache bundle."""
        try:
            os.remove(self.file_path_to(rid))
        except FileNotFoundError:
            return

    def drop(self) -> None:
        """Deletes all cache bundles."""
        try:
            shutil.rmtree(self.directory_path)
        except FileNotFoundError:
            return
</file>

<file path="ext/effector.py">
from typing import Callable
from enum import StrEnum
from rid_lib import RID
from .bundle import Bundle
from .cache import Cache
from .manifest import Manifest


class ActionType(StrEnum):
    dereference = "dereference"
    
class ProxyHandler:
    def __init__(self, effector):
        self.effector = effector
        
    def __getattr__(self, action_type):
        # shortcut to execute actions, use action type as function name
        def execute(rid: RID, *args, **kwargs):
            return self.effector.execute(action_type, rid, *args, **kwargs)
        return execute

class Effector:
    def __init__(self, cache: Cache | None = None):
        self.cache = cache
        self._action_table = {}
        self.run = ProxyHandler(self)
        
    def register(
        self, 
        action_type: ActionType, 
        rid_type: type[RID] | str | tuple[type[RID] | str]
    ):
        def decorator(func: Callable[[RID], Bundle | dict | None]):
            # accept type or list of types to register
            if isinstance(rid_type, (list, tuple)):
                rid_types = rid_type
            else:
                rid_types = (rid_type,)
            
            # retrieve context from RID objects, or use str directly
            for _rid_type in rid_types:
                if isinstance(_rid_type, type) and issubclass(_rid_type, RID):
                    context = _rid_type.context
                else:
                    context = _rid_type         
            
                self._action_table[(action_type, context)] = func
            
            return func
        return decorator
    
    def execute(self, action_type: str, rid: RID, *args, **kwargs):
        action_pair = (action_type, rid.context)
        if action_pair in self._action_table:
            func = self._action_table[action_pair]
            return func(rid, *args, **kwargs)
        else:
            raise LookupError(f"Failed to execute, no action found for action pair '{action_pair}'")
        
    def register_dereference(self, rid_type: type[RID] | str | tuple[type[RID] | str]):
        return self.register(ActionType.dereference, rid_type)
        
    def deref(
        self, 
        rid: RID, 
        hit_cache=True, # tries to read cache first, writes to cache if there is a miss
        refresh=False   # refreshes cache even if there was a hit
    ) -> Bundle | None:
        if (
            self.cache is not None and 
            hit_cache is True and 
            refresh is False
        ):
            bundle = self.cache.read(rid)
            if (
                bundle is not None and 
                bundle.contents is not None
            ):
                return bundle
        
        raw_data = self.execute(ActionType.dereference, rid)
        
        if raw_data is None: 
            return
        elif isinstance(raw_data, Bundle):
            bundle = raw_data
        else:            
            manifest = Manifest.generate(rid, raw_data)
            bundle = Bundle(manifest, raw_data)
        
        if (
            self.cache is not None and 
            hit_cache is True
        ):
            self.cache.write(bundle)
        
        return bundle
</file>

<file path="ext/manifest.py">
from datetime import datetime, timezone
from pydantic import BaseModel
from rid_lib.core import RID
from .utils import sha256_hash_json


class Manifest(BaseModel):
    """A portable descriptor of a data object associated with an RID.
    
    Composed of an RID, timestamp, and sha256 hash of the data object.
    """
    rid: RID
    timestamp: datetime
    sha256_hash: str
    
    @classmethod
    def generate(cls, rid: RID, data: dict) -> "Manifest":
        """Generates a Manifest using the current time and hashing the provided data."""
        return cls(
            rid=rid,
            timestamp=datetime.now(timezone.utc),
            sha256_hash=sha256_hash_json(data)
        )
</file>

<file path="ext/utils.py">
import json
import hashlib
from base64 import urlsafe_b64encode, urlsafe_b64decode
from dataclasses import asdict, is_dataclass
from datetime import datetime
from pydantic import BaseModel
from rid_lib import RID


def sha256_hash_json(data: dict | BaseModel):
    if isinstance(data, BaseModel):
        data = json.loads(data.model_dump_json())
    json_str = json.dumps(data, separators=(',', ':'), sort_keys=True)
    json_bytes = json_str.encode()
    hash = hashlib.sha256()
    hash.update(json_bytes)
    return hash.hexdigest()

def b64_encode(string: str):
    return urlsafe_b64encode(
        string.encode()).decode().rstrip("=")

def b64_decode(string: str):
    return urlsafe_b64decode(
        (string + "=" * (-len(string) % 4)).encode()).decode()

def json_serialize(obj):
    if isinstance(obj, RID):
        return str(obj)
    elif is_dataclass(obj) and not isinstance(obj, type):
        return json_serialize(asdict(obj))
    elif isinstance(obj, datetime):
        return obj.isoformat()
    elif isinstance(obj, (list, tuple)):
        return [json_serialize(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: json_serialize(value) for key, value in obj.items()}
    else:
        return obj
</file>

<file path="types/__init__.py">
from .http_s import HTTP, HTTPS
from .slack_channel import SlackChannel
from .slack_message import SlackMessage
from .slack_workspace import SlackWorkspace
from .slack_user import SlackUser
from .koi_net_node import KoiNetNode
from .koi_net_edge import KoiNetEdge
</file>

<file path="types/http_s.py">
from urllib.parse import urlsplit, urlunsplit

from rid_lib.core import RID
        
class HTTP(RID):
    scheme = "http"
    
    def __init__(self, authority, path, query, fragment):
        self.authority = authority
        self.path = path
        self.query = query
        self.fragment = fragment
        
    @property
    def reference(self):
        return urlunsplit((
            "",
            self.authority,
            self.path,
            self.query,
            self.fragment
        ))
        
    @classmethod
    def from_reference(cls, reference):
        uri_components = urlsplit(reference, scheme=cls.scheme)
        # excluding scheme component
        return cls(*uri_components[1:])

class HTTPS(HTTP):
    scheme = "https"
</file>

<file path="types/koi_net_edge.py">
import json
import hashlib
from rid_lib.core import ORN
from .koi_net_node import KoiNetNode


class KoiNetEdge(ORN):
    namespace = "koi-net.edge"
    
    def __init__(self, id):
        self.id = id
        
    @classmethod
    def generate(cls, source: KoiNetNode, target: KoiNetNode):
        edge_json = {
            "source": str(source),
            "target": str(target)
        }
        json_bytes = json.dumps(edge_json).encode()
        hash = hashlib.sha256()
        hash.update(json_bytes)
        hash.hexdigest()
        
        return cls(hash.hexdigest())
        
    @property
    def reference(self):
        return self.id
    
    @classmethod
    def from_reference(cls, reference):
        return cls(reference)
</file>

<file path="types/koi_net_node.py">
from uuid import uuid4
from rid_lib.core import ORN


class KoiNetNode(ORN):
    namespace = "koi-net.node"
    
    def __init__(self, name, uuid):
        self.name = name
        self.uuid = uuid
        
    @classmethod
    def generate(cls, name):
        return cls(name, uuid4())
        
    @property
    def reference(self):
        return f"{self.name}+{self.uuid}"
    
    @classmethod
    def from_reference(cls, reference):
        components = reference.split("+")
        if len(components) == 2:
            return cls(*components)
        else:
            raise ValueError("KOI-net Node reference must contain two '+'-separated components: '<name>+<uuid>'")
</file>

<file path="types/slack_channel.py">
from rid_lib.core import ORN
from .slack_workspace import SlackWorkspace


class SlackChannel(ORN):
    namespace = "slack.channel"
    
    def __init__(
            self,
            team_id: str,
            channel_id: str,
        ):
        self.team_id = team_id
        self.channel_id = channel_id
            
    @property
    def reference(self):
        return f"{self.team_id}/{self.channel_id}"
    
    @property
    def workspace(self):
        return SlackWorkspace(
            self.team_id
        )
        
    @classmethod
    def from_reference(cls, reference):
        components = reference.split("/")
        if len(components) == 2:
            return cls(*components)
        else:
            raise ValueError("Slack Channel reference must contain two '/'-separated components: '<team_id>/<channel_id>'")
</file>

<file path="types/slack_message.py">
from rid_lib.core import ORN
from .slack_channel import SlackChannel
from .slack_workspace import SlackWorkspace


class SlackMessage(ORN):
    namespace = "slack.message"
    
    def __init__(
            self,
            team_id: str,
            channel_id: str,
            ts: str,
        ):
        self.team_id = team_id
        self.channel_id = channel_id
        self.ts = ts
            
    @property
    def reference(self):
        return f"{self.team_id}/{self.channel_id}/{self.ts}"
    
    @property
    def workspace(self):
        return SlackWorkspace(
            self.team_id
        )
    
    @property
    def channel(self):
        return SlackChannel(
            self.team_id,
            self.channel_id
        )
        
    @classmethod
    def from_reference(cls, reference):
        components = reference.split("/")
        if len(components) == 3:
            return cls(*components)
        else:
            raise ValueError("Slack Message reference must contain three '/'-separated components: '<team_id>/<channel_id>/<ts>'")
</file>

<file path="types/slack_user.py">
from rid_lib.core import ORN
from .slack_workspace import SlackWorkspace


class SlackUser(ORN):
    namespace = "slack.user"

    def __init__(
            self,
            team_id: str,
            user_id: str,
        ):
        self.team_id = team_id
        self.user_id = user_id
            
    @property
    def reference(self):
        return f"{self.team_id}/{self.user_id}"
    
    @property
    def workspace(self):
        return SlackWorkspace(
            self.team_id
        )
        
    @classmethod
    def from_reference(cls, reference):
        components = reference.split("/")
        if len(components) == 2:
            return cls(*components)
        else:
            raise ValueError("Slack User reference must contain two '/'-separated components: '<team_id>/<user_id>'")
</file>

<file path="types/slack_workspace.py">
from rid_lib.core import ORN


class SlackWorkspace(ORN):
    namespace = "slack.workspace"

    def __init__(
            self,
            team_id: str,
        ):
        self.team_id = team_id
            
    @property
    def reference(self):
        return self.team_id
        
    @classmethod
    def from_reference(cls, reference):
        return cls(reference)
</file>

<file path="__init__.py">
from .core import RID, RIDType
from . import types, ext
</file>

<file path="consts.py">
ORN_SCHEME = "orn"
URN_SCHEME = "urn"
NAMESPACE_SCHEMES = (ORN_SCHEME, URN_SCHEME)
ABSTRACT_TYPES = ("RID", "DefaultType", "ORN", "URN")
</file>

<file path="core.py">
from typing import Any
from abc import ABCMeta, abstractmethod
from pydantic_core import core_schema, CoreSchema
from pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler
from pydantic.json_schema import JsonSchemaValue
from . import utils
from .consts import (
    ABSTRACT_TYPES, 
    NAMESPACE_SCHEMES, 
    ORN_SCHEME, 
    URN_SCHEME
)


class RIDType(ABCMeta):
    scheme: str | None = None
    namespace: str | None = None
    
    # maps RID type strings to their classes
    type_table: dict[str, type["RID"]] = dict() 
    
    def __new__(mcls, name, bases, dct):
        """Runs when RID derived classes are defined."""
            
        cls = super().__new__(mcls, name, bases, dct)
        
        # ignores built in RID types which aren't directly instantiated
        if name in ABSTRACT_TYPES:
            return cls
            
        if not getattr(cls, "scheme", None):
            raise TypeError(f"RID type '{name}' is missing 'scheme' definition")
        
        if not isinstance(cls.scheme, str):
            raise TypeError(f"RID type '{name}' 'scheme' must be of type 'str'")
        
        if cls.scheme in NAMESPACE_SCHEMES:
            if not getattr(cls, "namespace", None): 
                raise TypeError(f"RID type '{name}' is using namespace scheme but missing 'namespace' definition")
            if not isinstance(cls.namespace, str):
                raise TypeError(f"RID type '{name}' is using namespace scheme but 'namespace' is not of type 'str'")
                
        # check for abstract method implementation
        if getattr(cls, "__abstractmethods__", None):
            raise TypeError(f"RID type '{name}' is missing implemenation(s) for abstract method(s) {set(cls.__abstractmethods__)}")
        
        # save RID type to lookup table
        mcls.type_table[str(cls)] = cls
        return cls
    
    @classmethod
    def _new_default_type(mcls, scheme: str, namespace: str | None) -> type["RID"]:
        """Returns a new RID type deriving from DefaultType."""      
        if namespace:
            name = "".join([s.capitalize() for s in namespace.split(".")])
        else:
            name = scheme.capitalize()
        
        bases = (DefaultType,)
        
        if scheme in NAMESPACE_SCHEMES:
            if scheme == ORN_SCHEME:
                bases += (ORN,)
            elif scheme == URN_SCHEME:
                bases += (URN,)
        
        dct = dict(
            scheme=scheme, 
            namespace=namespace
        )
        
        return type(name, bases, dct)
    
    @classmethod
    def from_components(mcls, scheme: str, namespace: str | None = None) -> type["RID"]:
        context = utils.make_context_string(scheme, namespace)
        
        if context in mcls.type_table:
            return mcls.type_table[context]
        else:
            return mcls._new_default_type(scheme, namespace)
    
    @classmethod
    def from_string(mcls, string: str) -> type["RID"]:
        """Returns an RID type class from an RID context string."""
        
        scheme, namespace, _ = utils.parse_rid_string(string, context_only=True)
        return mcls.from_components(scheme, namespace)
     
    def __str__(cls) -> str:
        if cls.__name__ in ABSTRACT_TYPES: 
            return repr(cls)
        return utils.make_context_string(cls.scheme, cls.namespace)
    
    def __repr__(cls) -> str:
        if cls.__name__ in ABSTRACT_TYPES: 
            return type.__repr__(cls)
        return f"<RIDType '{str(cls)}'>"
    
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: type[Any], handler: GetCoreSchemaHandler
    ) -> CoreSchema:
                
        def not_abstract_type(rid_type: RIDType) -> RIDType:
            if rid_type.__name__ in ABSTRACT_TYPES:
                raise ValueError(f"RIDType must not be abstract type: {ABSTRACT_TYPES}")
            return rid_type
        
        # must be instance of RIDType not in ABSTRACT_TYPES
        from_instance_schema = core_schema.chain_schema([
            core_schema.is_instance_schema(RIDType),
            core_schema.no_info_plain_validator_function(not_abstract_type)
        ])
        
        # must be valid string, validated by RIDType.from_string (and prev schema)
        from_str_schema = core_schema.chain_schema([
            core_schema.str_schema(),
            core_schema.no_info_plain_validator_function(RIDType.from_string),
            from_instance_schema
        ])
        
        return core_schema.json_or_python_schema(
            json_schema=from_str_schema,
            python_schema=core_schema.union_schema([
                from_instance_schema,
                from_str_schema
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(str)
        )
        
    @classmethod
    def __get_pydantic_json_schema__(
        cls, _core_schema: CoreSchema, handler: GetJsonSchemaHandler
    ) -> JsonSchemaValue:
        json_schema = handler(core_schema.str_schema())
        json_schema.update({"format": "rid-type"})
        return json_schema
        
    # backwards compatibility
    @property
    def context(cls) -> str:
        return str(cls)
        

class RID(metaclass=RIDType):
    scheme: str | None = None
    namespace: str | None = None
    
    @property
    def context(self):
        return str(type(self))
    
    def __str__(self) -> str:
        return self.context + ":" + self.reference
    
    def __repr__(self) -> str:
        return f"<RID '{str(self)}'>"
    
    def __eq__(self, other) -> bool:
        if isinstance(other, self.__class__):
            return str(self) == str(other)
        else:
            return False
    
    def __hash__(self):
        return hash(str(self))
    
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: type[Any], handler: GetCoreSchemaHandler
    ) -> CoreSchema:
        
        # must be valid string, validated by RID.from_string, and an instance of the correct RID type
        from_str_schema = core_schema.chain_schema([
            core_schema.str_schema(),
            core_schema.no_info_plain_validator_function(RID.from_string),
            core_schema.is_instance_schema(cls)
        ])
        
        return core_schema.json_or_python_schema(
            json_schema=from_str_schema,
            python_schema=core_schema.union_schema([
                core_schema.is_instance_schema(cls),
                from_str_schema
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(str)
        )
    
    @classmethod
    def __get_pydantic_json_schema__(
        cls, _core_schema: CoreSchema, handler: GetJsonSchemaHandler
    ) -> JsonSchemaValue:
        json_schema = handler(core_schema.str_schema())
        json_schema.update({"format": "rid"})
        return json_schema
    
    @classmethod
    def from_string(cls, string: str) -> "RID":
        scheme, namespace, reference = utils.parse_rid_string(string)
        return RIDType.from_components(scheme, namespace).from_reference(reference)
    
    @abstractmethod
    def __init__(self, *args, **kwargs):
        ...
    
    @classmethod
    @abstractmethod
    def from_reference(cls, reference: str):
        ...
    
    @property
    @abstractmethod
    def reference(self) -> str:
        ...


class ORN(RID):
    scheme = ORN_SCHEME
    
class URN(RID):
    scheme = URN_SCHEME
    
class DefaultType(RID):
    def __init__(self, _reference):
        self._reference = _reference
        
    @classmethod
    def from_reference(cls, reference):
        return cls(reference)
    
    @property
    def reference(self):
        return self._reference
</file>

<file path="README.md">
# RID v3 Protocol

_This specification can be understood as the third iteration of the RID protocol, or RID v3. Previous versions include [RID v1](https://github.com/BlockScience/kms-identity/blob/main/README.md) and [RID v2](https://github.com/BlockScience/rid-lib/blob/v2/README.md)._

### Jump to Sections:

- [RID v3 Protocol](#rid-v3-protocol)
  - [Jump to Sections:](#jump-to-sections)
- [RID Core](#rid-core)
  - [Introduction](#introduction)
  - [Generic Syntax](#generic-syntax)
  - [Object Reference Names (previously RID v2)](#object-reference-names-previously-rid-v2)
  - [Examples](#examples)
  - [Implementation](#implementation)
    - [RID class](#rid-class)
    - [RID types](#rid-types)
    - [Creating your own types](#creating-your-own-types)
    - [Pydantic Compatibility](#pydantic-compatibility)
  - [Installation](#installation)
  - [Usage](#usage)
  - [Development](#development)
- [RID Extensions](#rid-extensions)
  - [Introduction](#introduction-1)
  - [Manifest](#manifest)
  - [Bundle](#bundle)
  - [Cache](#cache)
  - [Effector](#effector)

# RID Core

## Introduction

_Note: throughout this document the terms "resource", "digital object", and "knowledge object" are used roughly interchangeably._

Reference Identifiers (RIDs) identify references to resources primarily for usage within Knowledge Organization Infrastructure (KOI). The RID specification is informed by previous work on representing digital objects (see [Objects as Reference](https://blog.block.science/objects-as-reference-toward-robust-first-principles-of-digital-organization/)) in which objects are identified through a relationship between a reference and a referent. Under this model, RIDs are the _references_, and the resources they refer to are the _referents._ The _means of reference_ describes the relationship between the reference and referent.

```
(reference) -[means of reference]-> (referent)
```

As opposed to Uniform Resource Identifiers (URIs), RIDs are not intended to have universal agreement or a centralized management structure. However, RIDs are compatible with URIs in that _all URIs can be valid RIDs_. [RFC 3986](https://www.rfc-editor.org/info/rfc3986) outlines the basic properties of an URI, adding that "a URI can be further classified as a locator, a name or both." Location and naming can be considered two different means of reference, or methods of linking a reference and referent(s), where:

1. Locators identify resources by _where_ they are, with the referent being defined as the resource retrieved via a defined access method. This type of identifier is less stable, and the resource at the specified location could change or become unavailable over time.
2. Names identify resources by _what_ they are, acting as a more stable, location independent identifier. Resources identified by name are not always intended to be accessed, but some may be resolvable to locators. While the mapping from name to locator may not be constant the broader relationship between reference and referent should be.

## Generic Syntax

The generic syntax to compose an RID roughly mirrors URIS:

```
<context>:<reference>
```

Conceptually, the reference refers to the referent, while the context provides context for how to interpret the reference, or how to discriminate it from another otherwise identical RID. While in many cases the context simply maps to a URI scheme, the context may also include part of the "hierarchical part" (right hand side of a URI following the scheme).

## Object Reference Names (previously RID v2)

The major change from RID v2 to v3 was building compatibility with URIs, and as a result the previous RID v2 style identifiers are now implemented under the (unofficial) `orn:` URI scheme.

Object Reference Names (ORNs) identify references to objects, or resources identified independent of their access method. Given the previous definitions of identifiers, ORNs can be considered "names". They are intended to be used with existing resources which may already have well defined identifiers. An ORN identifies a resource by "dislocating" it from a specific access mechanism, maintaining a reference even if the underlying locator changes or breaks. ORNs are generally formed from one or more context specific identifiers which can be easily accessed for processing in other contexts.

ORNs are composed using the following syntax:

```
orn:<namespace>:<reference>
```

_Note: In previous versions, the namespace was split into `<space>.<form>`. Using a dot to separate a namespace in this way is still encouraged, but is not explicitly defined by this specification._

ORNs also implement a more complex context component: `orn:<namespace>`. The differences between the syntax of ORNs and generic URIs are summarized here:

```
<scheme>:<hierarchical-part>
\______/ \_________________/
    |                |
 context         reference
 ___|_________   ____|____
/             \ /         \
orn:<namespace>:<reference>
```

## Examples

In the current version there are two example implementations of RID types: HTTP/S URLs and Slack objects. The HTTP/S scheme is the most commonly used form of URI and uses the standard RID parsing, where the scheme `http` or `https` is equal to the context, and the hierarchical part is equal to the reference.

```
scheme  authority                  path
 _|_     ____|___  _________________|___________________
/   \   /        \/                                     \
https://github.com/BlockScience/rid-lib/blob/v3/README.md
\___/ \_________________________________________________/
  |                           |
context                   reference
```

The Slack objects are implemented as ORNs, and include workspaces, channels, messages, and users. The Slack message object's namespace is `slack.message` and its reference component is composed of three internal identifiers, the workspace id, channel id, and message id.

```
scheme namespace     team      channel      timestamp
 |   _____|_____   ___|___    ____|___   _______|_______
/ \ /           \ /       \ /         \ /               \
orn:slack.message:TA2E6KPK3/C07BKQX0EVC/1721669683.087619
\_______________/ \_____________________________________/
        |                            |
     context                     reference
```

By representing Slack messages through ORNs, a stable identifier can be assigned to a resource which can be mapped to existing locators for different use cases. For example, a Slack message can be represented as a shareable link which redirects to the Slack app or in browser app:

```
https://blockscienceteam.slack.com/archives/C07BKQX0EVC/p1721669683087619`
```

There's also a "deep link" which can open the Slack app directly (but only to a channel):

```
slack://open?team=TA2E6KPK3&id=C07BKQX0EVC
```

Finally, there's the backend API call to retrieve the JSON data associated with the message:

```
https://slack.com/api/conversations.replies?channel=C07BKQX0EVC&ts=1721669683.087619&limit=1
```

These three different locators have specific use cases, but none of them work well as long term identifiers of a Slack message. None of them contain all of the identifiers needed to uniquely identify the message (the shareable link comes close, but uses the mutable team name instead of the id). Even if a locator can fully describe an object of interested, it is not resilient to changes in access method and is not designed for portability into systems where the context needs to be clearly stated and internal identifiers easily extracted. Instead, we can represent a Slack message as an ORN and resolve it to any of the above locators when necessary.

## Implementation

### RID class

The RID class provides a template for all RID types and access to a global constructor. All RID instances have access to the following properties:

```python
class RID:
	scheme: str

	# defined for ORNs only
	namespace: str | None

	# "orn:<namespace>" for ORNs, otherwise equal to 'scheme'
	context: str

	# the component after namespace component for ORNs, otherwise after the scheme component
	reference: str

	@classmethod
	def from_string(cls, string: str) -> RID: ...

	# only callable from RID type classes, not the RID base class
	@classmethod
	def from_reference(cls, string: str) -> RID: ...
```

Example implementations can be found in [`src/rid_lib/types/`](https://github.com/BlockScience/rid-lib/tree/main/src/rid_lib/types).

### RID types

This library treats both RIDs and RID types as first class objects. Behind the scenes, the `RIDType` base class is the metaclass for all RID type classes (which are created by inheriting from the `RID`, `ORN`, `URN` classes) -- so RID types are the classes, and RIDs are the instances of those classes. You can access the type of an RID using the built-in type function: `type(rid)`. All RIDs with the same context are guaranteed to share the same RID type class. Even if that RID type doesn't have any explicit class implementation, a class will be automatically generated for it.

```python
class RIDType(ABCMeta):
    scheme: str | None = None
    namespace: str | None = None

    # maps RID type strings to their classes
    type_table: dict[str, type["RID"]] = dict()

    @classmethod
    def from_components(mcls, scheme: str, namespace: str | None = None) -> type["RID"]: ...

    @classmethod
    def from_string(mcls, string: str) -> type["RID"]: ...

    # backwards compatibility
    @property
    def context(cls) -> str:
        return str(cls)
```

The correct way to check the type of an RID is to check it's Python type. RID types can also be created using `RIDType.from_string`, which is also guaranteed to return the same class if the context component is the same.

```python
from rid_lib import RID, RIDType
from rid_lib.types import SlackMessage

slack_msg_rid = RID.from_string("orn:slack.message:TA2E6KPK3/C07BKQX0EVC/1721669683.087619")

assert type(slack_msg_rid) == SlackMessage
assert SlackMessage == RIDType.from_string("orn:slack.message")
```

### Creating your own types

In order to create an RID type, follow this minimal implementation:

```python
class MyRIDType(RID): # inherit from `RID` OR `ORN` base classes
	# define scheme for a generic URI type
	scheme = "scheme"
	# OR a namespace for a ORN type
	namespace = "namespace"

	# instantiates a new RID from internal components
	def __init__(self, internal_id):
		self.internal_id = internal_id

	# returns the reference component
	@property
	def reference(self):
		# should dynamically reflect changes to any internal ids
		return self.internal_id

	# instantiates of an RID of this type given a reference
	@classmethod
	def from_reference(cls, reference):
		# in a typical use case, the reference would need to be parsed

		# raise a ValueError if the reference is invalid
		if len(reference) > 10:
			raise ValueError("Internal ID must be less than 10 characters!")

		return cls(reference)
```

### Pydantic Compatibility

Both RIDs and RID types are Pydantic compatible fields, which means they can be used directly within a Pydantic model in very flexible ways:

```python
class Model(BaseModel):
	rid: RID
	slack_rid: SlackMessage | SlackUser | SlackChannel | SlackWorkspace
	rid_types: list[RIDType]
```

## Installation

This package can be installed with pip for use in other projects.

```
pip install rid-lib
```

It can also be built and installed from source by cloning this repo and running this command in the root directory.

```
pip install .
```

## Usage

RIDs are intended to be used as a lightweight, cross platform identifiers to facilitate communication between knowledge processing systems. RID objects can be constructed from any RID string using the general constructor `RID.from_string`. The parser will match the string's context component and call the corresponding `from_reference` constructor. This can also be done directly on any RID type class via `MyRIDType.from_reference`. Finally, each context class provides a default constructor which requires each subcomponent to be indvidiually specified.

```python
from rid_lib import RID
from rid_lib.types import SlackMessage

rid_obj1 = RID.from_string("orn:slack.message:TA2E6KPK3/C07BKQX0EVC/1721669683.087619")
rid_obj2 = SlackMessage.from_reference("TA2E6KPK3/C07BKQX0EVC/1721669683.087619")
rid_obj3 = SlackMessage(team_id="TA2E6KPK3", channel_id="C07BKQX0EVC", ts="1721669683.087619")

assert rid_obj1 == rid_obj2 == rid_obj3

# guaranteed to be defined for all RID objects
print(rid_obj1.scheme, rid_obj1.context, rid_obj1.reference)

# special parameters for the slack.message context
print(rid_obj1.team_id, rid_obj1.channel_id, rid_obj1.ts)
```

If an RID type hasn't been implemented as a class, it can still be parsed by the general constructor if provisional contexts are allowed (enabled by default). In this case a provisional context class is generated on the fly providing the minimal RID type implementation (`reference` property, `from_reference` class method, `__init__` function).

```python
test_obj1 = RID.from_string("test:one")
test_obj2 = RID.from_string("test:one")

assert test_obj1 == test_obj2
```

## Development

Build and install from source with development requirements:

```
pip install .[dev]
```

Run unit tests:

```
pytest --cov=rid_lib
```

To build and upload to PyPI:
(Remember to bump the version number in pyproject.toml first!)

```
python -m build
```

Two new build files should appear in `dist/`, a `.tar.gz` and `.whl` file.

```
python -m twine upload -r pypi dist/*
```

Enter the API key and upload the new package version.

# RID Extensions

## Introduction

In addition to the core implementation of the RID specification, this library also provides extended functionality through objects and patterns that interface with RIDs.

## Manifest

A manifest is a portable descriptor of a data object associated with an RID. It is composed of an RID and metadata about the data object it describes (currently a timestamp and sha256 hash). The name "manifest" comes from a shipping metaphor: a piece of cargo has contents (the stuff inside of it) and a manifest (a paper describing the contents and providing tracking info). In the KOI network ecosystem, a manifest serves a similar role. Manifests can be passed around to inform other nodes of a data objects they may be interested in.

Below are the accessible fields and methods of a Manifest object, all are required.

```python
class Manifest(BaseModel):
	rid: RID
	timestamp: datetime
	sha256_hash: str

	# generates a Manifest using the current datetime and the hash of the provided data
	@classmethod
	def generate(cls, rid: RID, data: dict) -> Manifest: ...
```

## Bundle

A bundle is composed of a manifest and contents. This is the "piece of cargo" in the shipping metaphor described above. It's the construct used to transfer and store the RIDed knowledge objects we are interested in.

```python
class Bundle(BaseModel):
    manifest: Manifest
    contents: dict

	@classmethod
    def generate(cls, rid: RID, contents: dict) -> Bundle: ...
```

_Manifests and bundles are implemented as Pydantic models, meaning they can be initialized with args or kwargs. They can also be serialized with `model_dump()` and `model_dump_json()`, and deserialized with `model_validate()` and `model_validate_json()`._

## Cache

The cache class allows us to set up a cache for reading and writing bundles to the local filesystem. Each bundle is stored as a separate JSON file in the cache directory, where the file name is base 64 encoding of its RID. Below are the accessible fields and methods of a Cache.

```python
class Cache:
    def __init__(self, directory_path: str): ...

    def file_path_to(self, rid: RID) -> str: ...

    def write(self, cache_bundle: Bundle) -> Bundle: ...

    def exists(self, rid: RID) -> bool: ...
    def read(self, rid: RID) -> Bundle | None: ...
    def list_rids(
		self, rid_types: list[RIDType] | None = None
	) -> list[RID]: ...

    def delete(self, rid: RID) -> None: ...
    def drop(self) -> None: ...
```

## Effector

_The effector has not been used or updated in awhile, it may be removed or refactored in the future._

The effector is the most abstract construct out of the rid-lib extensions. It acts as an "end effector", performing actions on/with RIDs. More concretely, it allows you to define and bind functions to a specific action type and RID context. The most obvious use case for this is as a dereferencer (and this use case has added functionality): a dereference function can be defined for different types of RIDs, and the effector will automatically choose the correct one to run based on the context of the RID passed in. Below are the accessible fields and methods of Effector.

```python
class Effector:
	cache: Cache | None

	# alias to 'execute', allows actions to be run by calling:
	# effector.run.<action_type>(rid: RID, *args, **kwargs)
	run: ProxyHandler

    def __init__(self, cache: Cache | None = None): ...

	# decorator used to register actions to the effector:
	# @effector.register(action_type, rid_type)
    def register(
        self,
        action_type: ActionType,
		# rid_type may be singular or multiple strings or RID type classes
        rid_type: Type[RID] | str | tuple[Type[RID] | str]
    ): ...

	# decorator used to register dereference actions to the effector
	# (alias to 'register', sets action_type=ActionType.dereference)
    def register_dereference(
		self,
		rid_type: Type[RID] | str | tuple[Type[RID] | str]
	): ...

	def execute(
		self,
		action_type: str,
		rid: RID,
		*args,
		**kwargs
	): ...

	# special handler for 'dereference' actions, returns a CacheBundle instead of dict, optionally interacts with cache
	# note: different behavior than calling 'dereference' action with 'execute' or 'run'
    def deref(
        self,
        rid: RID,
        hit_cache=True, # tries to read cache first, writes to cache if there is a miss
        refresh=False   # refreshes cache even if there was a hit
    ) -> CacheBundle | None: ...

```

Registering and calling actions with an Effector:

```python
import requests
from rid_lib import RID
from rid_lib.ext import Cache, Effector, ActionType
from rid_lib.types import HTTP, HTTPS

cache = Cache("my_cache")
effector = Effector(cache)

@effector.register_dereference((HTTP, HTTPS))
def dereference_url(url):
	return requests.get(str(url)).json()

my_url = RID.from_string("https://jsonplaceholder.typicode.com/todos/1")

# equivalent actions, returns dict
effector.execute(ActionType.dereference, url)
effector.execute("dereference", url)
effector.run.dereference(url)

# special dereference handler, returns CacheBundle
effector.deref(url)
effector.deref(url, hit_cache=False)
effector.deref(url, refresh=True)
```
</file>

<file path="utils.py">
from .consts import NAMESPACE_SCHEMES


def make_context_string(scheme: str, namespace: str | None):
    if scheme in NAMESPACE_SCHEMES:
        if namespace is None:
            raise TypeError("Cannot create context for namespace scheme '{scheme}' when namespace is None")
        return scheme + ":" + namespace
    else:
        if namespace is not None:
            raise TypeError("Cannot create context for non-namespace scheme '{scheme}' when namespace is not None")
        return scheme

def parse_rid_string(
    string: str, 
    context_only: bool = False
) -> tuple[str, str | None, str | None]:
    """Parses RID (or context) string into scheme, namespace, and reference components."""
    
    scheme = None
    namespace = None
    reference = None
    
    if not isinstance(string, str):
        raise TypeError(f"RID type string '{string}' must be of type 'str'")
    
    i = string.find(":")
    
    if i < 0:
        if not context_only:
            raise TypeError(f"RID string '{string}' should contain a ':'-separated context and reference componeont")
        
        scheme = string
        namespace = None
        
        if scheme in NAMESPACE_SCHEMES:
            raise TypeError(f"RID type string '{string}' is a namespace scheme but is missing a namespace component")
        
    else:        
        scheme = string[:i]
        if scheme in NAMESPACE_SCHEMES:
            j = string.find(":", i+1)
        
            if j < 0:
                if context_only:
                    namespace = string[i+1:]
                else:
                    raise TypeError(f"RID string '{string}' is missing a reference component")
            else:
                if context_only:
                    raise TypeError(f"RID type string '{string}' should contain a maximum of two ':'-separated components")
                else:
                    namespace = string[i+1:j]
                    reference = string[j+1:]
        else:
            if context_only:
                raise TypeError(f"RID type string '{string}' contains a ':'-separated namespace component, but scheme doesn't support namespaces")
            else:
                reference = string[i+1:]
    
    if scheme == "":
        raise TypeError(f"RID type string '{string}' cannot have an empty scheme")
    
    if namespace == "":
        raise TypeError(f"RID type string '{string}' cannot have an empty namespace")
    
    if reference == "":
        raise TypeError(f"RID string '{string}' cannot have an empty reference")
    
    return scheme, namespace, reference
</file>

</files>

